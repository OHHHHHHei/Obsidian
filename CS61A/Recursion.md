# 建立一个递归函数
1. 定义函数名
2. **确定基线情况** （这十分重要，因为你的所有递归最终都会收束于此）剪枝应该包含在第一个base case
3. 检查是否是基线情况（base case）
4. 若是基线情况，则不进行递归
5. 如果不是基线情况，则进行递归，即写出递归公式

将递归调用看作一种函数抽象这一思想，就是所谓“**递归的信仰之跃（recursive leap of faith）**”。我们根据函数自身来定义一个函数，但在验证函数的正确性时，我们只需相信在更简单的情况下，函数同样能正确工作。

---
# 递归可能导致的问题

## 栈溢出（stack overflow）

在每次递归时，调用的函数会独立生成一个帧（frame）
如果递归次数过多，或者基线条件设置错误导致无限递归，那么可能就会导致栈溢出
## 重复计算

递归可能会产生大量的重复计算导致效率降低

---
# 互递归

当一个递归过程被划分到两个相互调用的函数中时，这两个函数被称为是互递归的（mutually recursive）。
作为另一个互递归的例子，请思考一个两人博弈的情景，桌子上最初有 n 个石子，玩家轮流从桌面上拿走一个或两个石子，拿走最后一个石子的玩家获胜。假设 Alice 和 Bob 在玩这个游戏，两个人都使用一个简单的策略：

- Alice 总是取走一个石子
- 如果桌子上有偶数个石子，Bob 就拿走两个石子，否则就拿走一个石子

给定 n 个初始石子且 Alice 先开始拿，谁会赢得游戏？

该问题的一个自然分解是将每个策略 **封装** 在其自己的函数中。这使我们可以修改一个策略而不会影响其他策略，保持两者之间的抽象界限（abstraction barrier）。为了融入游戏的回合制性质，这两个函数在每个回合结束时互相调用。
```python
>>> def play_alice(n):
        if n == 0:
            print("Bob wins!")
        else:
            play_bob(n-1)

>>> def play_bob(n):
        if n == 0:
            print("Alice wins!")
        elif is_even(n):
            play_alice(n-2)
        else:
            play_alice(n-1)

>>> play_alice(20)
Bob wins!
```

在函数 `play_bob` 中，我们看到多个递归调用可能会出现一个函数体中。虽然在这个例子中，每次调用 `play_bob` 最多只会调用一次 `play_alice`。在下个小节中，我们将会思考当单个函数调用同时直接进行多个递归函数调用时会发生什么。

---
# 树递归

另一种常见的计算模式称为树递归（tree recursion），在这种模式中，函数会多次调用自己。例如计算斐波那契数列，其中的每个数都是前两个数的和。
如下是斐波那契数列在树递归下的解释图
![[Pasted image 20250703153851.png]]
其中有一个重要的问题就是**重复计算**
这个问题会导致这个算法效率在数字变大后变得极低，我们会在后面的章节中解决这个问题


# 实例：分割数的计算
### 背景：
求正整数 n 的分割数，最大部分为 m，即 n 可以分割为不大于 m 的正整数的和，并且按递增顺序排列。例如，使用 4 作为最大数对 6 进行分割的方式有 9 种。
```
1.  6 = 2 + 4
2.  6 = 1 + 1 + 4
3.  6 = 3 + 3
4.  6 = 1 + 2 + 3
5.  6 = 1 + 1 + 1 + 3
6.  6 = 2 + 2 + 2
7.  6 = 1 + 1 + 2 + 2
8.  6 = 1 + 1 + 1 + 1 + 2
9.  6 = 1 + 1 + 1 + 1 + 1 + 1
```
我们将定义一个名为 `count_partitions(n, m)` 的函数，该函数返回使用 $m$ 作为最大部分对 $n$ 进行分割的方式的数量。这个函数有一个使用树递归的简单的解法，它基于以下的观察结果：
使用最大数为 $m$ 的整数分割 $n$ 的方式的数量等于
1. 使用最大数为 $m$ 的整数分割 $n-m$ 的方式的数量，加上
2. 使用最大数为 $m-1$ 的整数分割 $n$ 的方式的数量

为了实现它，我们需要指定以下的基线情况(base case)：
1. 整数 $0$ 只有一种分割方式
2. 负整数 $n$ 无法分割，即 $0$ 种方式
3. 任何大于 $0$ 的正整数 $n$ 使用 $0$ 或更小的部分进行分割的方式数量为 $0$

正式代码如下
```python
>>> def count_partitions(n, m):
        """计算使用最大数 m 的整数分割 n 的方式的数量"""
        if n == 0:
            return 1
        elif n < 0:
            return 0
        elif m == 0:
            return 0
        else:
            return count_partitions(n-m, m) + count_partitions(n, m-1)

>>> count_partitions(6, 4)
9
>>> count_partitions(5, 5)
7
>>> count_partitions(10, 10)
42
>>> count_partitions(15, 15)
176
>>> count_partitions(20, 20)
627
```

# 递归通常思路

将总任务分为小任务，分成现在应该解决的情况和待会应该解决的情况。相应变量也应改变后传入。