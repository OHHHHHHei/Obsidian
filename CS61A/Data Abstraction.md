核心思想是，将数据的使用方式与其具体的表示方式（即如何存储）分离开来。这就像函数抽象一样，让你可以在不关心底层实现细节的情况下使用数据。这样做的好处是：

- **模块化：** 程序更容易设计、维护和修改。
    
- **灵活性：** 即使数据的内部结构发生变化，只要其行为保持一致，使用数据的代码就无需更改。

文章通过一个**有理数**（即可以表示为两个整数之比的数）的例子来阐述这个概念。它展示了如何：

1. **定义抽象：** 首先“凭空”设想出创建有理数的构造函数 `rational(n, d)` 和获取分子、分母的选择器函数 `numer(x)`、`denom(x)`。
    
2. **使用抽象：** 在不关心这些函数如何实现的情况下，直接用它们来编写有理数的加法和乘法等算术运算。
    
3. **实现抽象：** 随后，文章介绍了如何使用 Python 的列表（`list`）来具体实现有理数的表示（例如，用一个包含两个元素的列表来存储分子和分母），并定义之前设想的构造函数和选择器函数。
    
4. **建立抽象屏障 (Abstraction Barriers)：** 这个原则将程序分为不同的层次。每一层都通过抽象接口与数据进行交互，而不应“越界”直接访问更底层的数据表示。这保证了代码的健壮性。

数据的本质在于其**行为**，而不在于其具体的表示形式。任何能够满足所需行为的实现方式都是有效的，并举了一个用函数来实现数据对（pair）的例子，进一步证明了数据抽象的强大和灵活性。

# Abstraction Barriers

在继续更多复合数据和数据抽象的示例之前，让我们考虑一下有理数示例引发的一些问题。我们根据构造函数 `rational` 和选择器函数 `numer` 和 `denom` 来定义操作。一般来说，数据抽象的基本思想是：确定一组基本操作，根据这些操作可以表达对某种值的所有操作，然后仅使用这些操作来操作数据。通过以这种方式限制操作的使用，在不改变程序行为的情况下改变抽象数据的表示会容易得多。

对于有理数，程序的不同部分使用不同的操作来处理有理数，如此表中所述。

| 该程序的一部分...    | 把有理数当作... | 仅使用...                                                            |
| ------------- | --------- | ----------------------------------------------------------------- |
| 使用有理数进行计算     | 整个数据值     | `add_rational, mul_rational, rationals_are_equal, print_rational` |
| 创建有理数或操作有理数   | 分子和分母     | `rational, numer, denom`                                          |
| 为有理数实现选择器和构造器 | 二元列表      | 列表字面量和元素选择                                                        |
|               |           |                                                                   |

在上面的每一层中，最后一列中的函数会强制实施抽象屏障（abstraction barrier）。这些功能会由更高层次调用，并使用较低层次的抽象实现。

当程序中有一部分本可以使用更高级别函数但却使用了低级函数时，就会违反抽象屏障。例如，计算有理数平方的函数最好用 `mul_rational` 实现，它不对有理数的实现做任何假设。

```python
>>> def square_rational(x):
        return mul_rational(x, x)
```

直接引用分子和分母会违反一个抽象屏障。

```python
>>> def square_rational_violating_once(x):
        return rational(numer(x) * numer(x), denom(x) * denom(x))
```

假设有理数会表示为双元素列表将违反两个抽象屏障。

```python
>>> def square_rational_violating_twice(x):
        return [x[0] * x[0], x[1] * x[1]]
```

抽象屏障使程序更易于维护和修改。依赖于特定表示的函数越少，想要更改该表示时所需的更改就越少。
# 数据的核心属性

**数据的最核心属性是它“要干什么”（它的行为和接口），而不是它“如何实现”（它的内部结构）。**

这正是**数据抽象**思想的精髓。

- **“要干什么”** -> 这是数据的**公开行为**（API、接口），是它向外界做出的承诺。例如，“我是一个有理数，你随时可以问我分子和分母是什么”。
    
- **“如何实现”** -> 这是数据的**内部秘密**（实现细节），是它如何兑现承诺的方式。例如，它在内部用列表 `[n, d]` 来偷偷记下分子和分母。
    

只要这个“承诺”不变，内部的“秘密”无论怎么修改，都不会影响到信任它的其他代码。这个原则是现代软件工程的基石之一。