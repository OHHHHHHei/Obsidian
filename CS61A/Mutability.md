# 对象是什么

简单来说，一个**对象 (object)** 就是一个将 **数据 (data)** 和操作这些**数据的函数 (functions)** 捆绑在一起的集合体。

想象一下，你不能直接制造一辆能开的汽车，你得先有这辆车的**设计蓝图 (blueprint)**。

- **类 (Class):** 就是那个**设计蓝图**。它定义了一类事物应该具备的通用属性和功能。
    
    - **属性 (Attributes):** 蓝图上会写明，所有“汽车”都应该有 `颜色 (color)`、`型号 (model)`、`当前速度 (speed)` 等等。这些是数据。
        
    - **方法 (Methods):** 蓝图上还会定义，所有“汽车”都能执行哪些操作，比如 `加速 (accelerate)`、`刹车 (brake)`、`鸣笛 (honk)`。这些是函数。
        
- **对象 (Object):** 就是根据这张蓝图**制造出来的具体、真实的汽车**。每一个对象都是一个独立的实体，我们称之为“类的实例 (instance)”。

使用对象的最大好处是**封装 (Encapsulation)** 和**抽象 (Abstraction)**。

# 可变序列对象 

可变数据用来表示那些会在程序运行期间发生变化的数据。一个对象可能通过某些操作更改自身的属性。举例来说，一个列表中的数据是可能会发生变化的。大部分变化的发生，都是通过调用列表实例的方法来触发的。对序列对象（如列表）进行的操作，像 `pop`、`append`、`insert` 等，通常被称为**可变序列操作（Mutable Sequence Operations）**，因为它们会**改变或修改**序列本身。

我们可以举一个例子：

中国发明了扑克牌。在最早的扑克牌中，只有三种花色，分别代表了当时货币的面额：

```python
>>> chinese = ['coin', 'string', 'myriad']  # 一组字符串列表
>>> suits = chinese                         # 为同一个列表指定了两个不同的变量名
```

当扑克牌传到欧洲后，西班牙的纸牌中只剩下 `coin` 这一种花色：

```python
>>> suits.pop()             # 从列表中移除并返回最后一个元素
'myriad'
>>> suits.remove('string')  # 从列表中移除第一个与参数相同的元素
```

随着时间推移，又额外演变出了另外三种花色：

```python
>>> suits.append('cup')              # 在列表最后插入一个元素
>>> suits.extend(['sword', 'club'])  # 将另外一个列表中的所有元素添加到当前列表最后
```

同时，意大利人给花色 `swords` 叫 `spades`：

```python
>>> suits[2] = 'spade'  # 替换某个元素
```

这样我们就得到了一副传统意大利扑克牌的所有花色：

```python
>>> suits
['coin', 'cup', 'spade', 'club']
```

现在美国使用的扑克牌实际上是法国的变种，修改了前两种花色：

```python
>>> suits[0:2] = ['heart', 'diamond']  # 替换一组数据
>>> suits
['heart', 'diamond', 'spade', 'club']
```

除此之外，还有插入、排序、反转列表的方法。所有这些方法都是直接改变了目标列表的值，而不是创建了一个新的列表对象。

**数据共享和身份（Sharing and Identity）。** 正是由于我们没有在操作数据时创建新的列表，而是直接操作的源数据，这就导致变量 `chinese` 也被改变了，因为它和变量 `suits` 绑定到时同一个列表！
我们可以利用列表的构造器函数 `list` 来对一个列表进行复制。复制完成后，两个列表数据的改动不会再影响彼此，除非二者共享了同一份数据。

```python
>>> nest = list(suits)  # 复制一个与 suits 相同的列表，并命名为 nest
>>> nest[0] = suits     # 创建一个嵌套列表，列表第一项是另一个列表
```

跟C语言中的指针有异曲同工之妙
**一个类比：**
- **C 的指针** 就像是告诉你一个宝藏的**精确经纬度** (`35.6895° N, 139.6917° E`)。你可以直接操作这个地址，甚至可以自己计算旁边的坐标，但风险自负。
- **Python 的引用** 就像是告诉你宝藏在“**东京塔**”这个地标里。你只知道这个名字，并使用这个名字来导航。你不需要、也不允许知道它的具体经纬度。系统（Python 解释器）会为你处理所有底层的寻址，既安全又方便。

# 元组（tuple）

**元组。** 元组是指 Python 内置类型 `tuple` 的实例对象，其是不可变序列。我们可以将不同数据用逗号分隔，用这种字面量的方式即可以创建一个元组。括号并不是必须的，但是一般都会加上。元组中可以放置任意对象。

```python
>>> 1, 2 + 3
(1, 5)
>>> ("the", 1, ("and", "only"))
('the', 1, ('and', 'only'))
>>> type( (10, 20) )
<class 'tuple'>
```

和列表相同，元组有确定的长度，并支持元素索引。元组还有一些与列表相同的方法，比如 `count` 和 `index`。

```python
>>> code = ("up", "up", "down", "down") + ("left", "right") * 2
>>> len(code)
8
>>> code[3]
'down'
>>> code.count("down")
2
>>> code.index("left")
4
```

但是，列表中那些用于操作列表元素的方法并不适用于元组，因为元组是不可变的。尽管无法修改元组的元素，但是如果元组中的元素本身是可变数据，那我们也是可以对该元素进行操作的。
## 元组解包

元组解包（Tuple Unpacking），也叫序列解包，是 Python 中一个非常方便的特性。简单来说，它允许你将一个元组（或其他任何序列，比如列表、字符串等）的元素，一次性赋值给多个变量。

```Python
coordinates = (10, 20)  # 一个包含两个元素的元组
x, y = coordinates      # 解包！
print(x)  # 输出: 10
print(y)  # 输出: 20
```
# 字典

### 核心特性

1. **键-值存储 (Key-Value Pairs)** 字典中的每个元素都由一个唯一的“键”（key）和与之对应的“值”（value）组成。这种结构类似于现实生活中的字典，你可以通过查找一个词（键）来找到它的释义（值）。
2. ```python
  # 示例：一个存储用户信息的字典
   user_profile = {
       "username": "Alex",
       "age": 30,
       "is_active": True,
       "courses": ["Math", "Physics"]
       }
```
3. **键 (Key) 的要求**
- **唯一性**：在一个字典中，键必须是唯一的。如果你尝试用一个已经存在的键来添加新的值，原来的值就会被覆盖。

- **不可变性**：键必须是不可变的数据类型。最常用的键是字符串和数字。元组（tuple）也可以作为键，但列表（list）和另一个字典（dict）则不能，因为它们是可变的。
```python
 # 正确的键
    valid_keys = {
            "name": "Guido",
        1991: "Year of Python's birth",
        ("host", "port"): ("127.0.0.1", 8080)
    }
    
    # 错误示例：使用列表作为键会引发 TypeError
    # invalid_dict = {["a", "b"]: "value"} # 这会报错
    ```
4. **可变性 (Mutable)** 字典本身是可变的。这意味着你可以在程序运行时随时添加、修改或删除字典中的键-值对。
5. **动态性 (Dynamic)** 字典可以根据需要动态地增长或缩小，你不需要在创建时预先指定它的大小。
6. **无序与有序**
- 在 **Python 3.6 及更早版本**中，字典是**无序**的。这意味着当你遍历字典时，元素的顺序是不确定的。
- 从 **Python 3.7 版本开始**，字典被正式规定为**有序**的。这意味着字典会保持你插入键-值对时的顺序。在迭代时，元素会按照插入的顺序出现。
4. **高效的查找** 字典的底层实现是哈希表（Hash Table），这使得它在根据键查找值时的速度非常快，时间复杂度接近 O(1)，即与字典的大小无关。

访问元素使用方括号或者`.get()`
遍历字典
```python
user = {"username": "Grace", "id": 101, "role": "Admin"}

# 遍历所有的键 (默认行为)
print("--- 遍历键 ---")
for key in user:
    print(key)

# 遍历所有的键 (使用 .keys())
print("--- 遍历键 (.keys()) ---")
for key in user.keys():
    print(key)

# 遍历所有的值 (使用 .values())
print("--- 遍历值 (.values()) ---")
for value in user.values():
    print(value)

# 遍历所有的键值对 (使用 .items())
print("--- 遍历键值对 (.items()) ---")
for key, value in user.items():
    print(f"{key}: {value}")
```


is比较地址

`==` 比较内容