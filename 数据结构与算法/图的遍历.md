
图的遍历是指从图的任一顶点出发，访问图中所有的顶点，并且保证每个顶点**只被访问一次** 。

**难点（Challenges）：** 遍历图比遍历树要复杂，主要有两点：

1. **没有固定起点：** 图中顶点都是平等的，从不同的点出发，遍历序列会不同 。**对策：** 算法需要指定一个起始点。
2. **存在环路（Cycles）：** 你可能从 $v$ 出发，走了一圈又回到了 $v$ 。**对策：** 必须设置一个“标志数组”（比如 `visited[]`），记录谁被访问过了，避免死循环。

**两大策略：** 遍历图主要有两种方法：**深度优先搜索 (DFS)** 和 **广度优先搜索 (BFS)** 。

# DFS深度优先搜索

- 你从起点 $v$ 出发，（先在 $v$ 墙上做个记号 `visited[v]=1`）。
- 你面前有3条岔路（邻接点 $w_1, w_2, w_3$）。
- 你**随便选一条**（比如 $w_1$）。
- 你到了 $w_1$（做记号 `visited[w1]=1`），$w_1$ 又有2条岔路（$u_1, u_2$）。
- 你**再随便选一条**（比如 $u_1$），继续扎进去...
- 这就是“**深度**”：优先往“深”处走。
- 直到你走到一个死胡同（所有邻接点都做过记号了），你**退回**到上一个路口（比如 $w_1$），看 $w_1$ 还有没有你没走过的岔路（比如 $u_2$）。
- 如果有，就从 $u_2$ 再扎进去；如果 $w_1$ 也没路了，就再退回到 $v$。
- 这就是“**回溯**”。

C语言具体实现

```c
void DFS(Graph G, int v, int visited[])  // v 是起始点下标，visited[] 遍历前已初始化为全 0
{
    struct ArcNode *temp;
    int i;

    printf("%d", v);          // 访问下标为 v 的顶点
    visited[v] = 1;           // 下标为 v 的顶点已访问过

    temp = G.adjlist[v].firstarc;  // 取顶点 v 的第一个邻接点

    while (temp != NULL)
    {
        i = temp->adjvex;         // 邻接点在数组中的下标
        if (!visited[i])
            DFS(G, i, visited);   // 递归访问未访问的邻接点
        temp = temp->nextarc;     // （递归返回后）继续看 v 的下一个邻接点
    }
}
```

**非递归算法**

- **为什么需要？** 递归的本质就是用栈。如果图的“深度”特别深，递归可能会导致**栈溢出**
- **怎么做？** 用一个你自己的**栈 (Stack)**。
    1. $v$ 进栈。
    2. 循环（当栈不为空时）：
    3. 弹出栈顶 $v$ 并访问（如果它没被访问过的话）。
    4. **关键：** 把 $v$ 的**所有**未访问邻接点**反序**压入栈中。（为什么要反序？因为栈是“后进先出”，你希望编号小的邻接点先被访问，就得最后压栈）。
    - “访问栈顶顶点的未访问的邻接点...当v的所有邻接点都访问后, $v_j$ 出栈” 是一种常见的实现，它模拟了递归“回溯”的过程。

你需要两样东西：

- **一个栈 (Stack)**：用来记录“待会儿要去探索的路口”。因为栈是“后进先出”的，这正好符合“先处理最新发现的岔路（往深处走），处理完了再回退”的逻辑。
- **一个记录表 (Visited Array)**：用来记录哪些点已经去过了，防止在环路里转圈圈。

### 2. 开始探险（初始化）

1. 选定一个**起始顶点**（比如 A）。
2. 把 A 扔进**栈**里。
3. （可选）此时还没算真正访问 A，只是把它加入了“待办列表”。
### 3. 循环过程（只要栈里还有东西，就不能停）

只要栈不是空的，就重复做以下动作：
- **第一步：弹栈（取出当前位置）**
    - 从栈顶拿出一个顶点（假设是 V）。这个 V 就是你现在站的地方。
- **第二步：检查与访问**
    - 看看记录表：V 以前来过吗？
    - 如果**来过**：直接忽略，回到第一步（继续弹下一个）。
    - 如果**没来过**：
        1. **标记** V 为“已访问”。
        2. **处理** V（比如打印它的名字）。
- **第三步：寻找下家（压栈）**
    - 环顾四周，找到 V 的所有**邻接点**（邻居）。
    - 把这些**没被访问过**的邻居，统统压入栈中。
    - **关键细节**：为了保证访问顺序和递归版本一致（比如先访问邻居1，再访问邻居2），通常需要**按相反的顺序**把邻居压栈（先压邻居2，再压邻居1）。这样下次弹栈时，邻居1 就会先出来。
### 4. 结束
当**栈变空了**，说明所有能走通的路都走完了，所有能回溯的岔路口都查过了。探险结束。
## 时间复杂度

**为什么 $O(n+e)$（邻接表）**
- $n$：每个顶点 $v$ 都会被 `DFS(v)` 调用**一次**（因为有 `visited` 数组）。所以访问 $n$ 个顶点是 $O(n)$。
- $e$：在遍历过程中，你访问了 $n$ 个顶点的**所有**邻接表。对于有向图，所有邻接表的边结点总数是 $e$；对于无向图是 $2e$。你总共会检查 $e$（或 $2e$）条边。
- 合起来就是 $O(n+e)$。

**为什么 $O(n^2)$（邻接矩阵）？**
- $n$：访问 $n$ 个顶点是 $O(n)$。
- **瓶颈在这里：** 当你访问一个顶点 $v$ 时，为了找到它的所有“未访问邻接点”，你必须**遍历矩阵的第 $v$ 行**（从 $j=0$ 到 $n-1$）
- 这个“找邻接点”的操作，对每个顶点都要花 $O(n)$ 的时间。
- 总共 $n$ 个顶点，所以是 $O(n \times n) = O(n^2)$。


# BFS广度优先搜索

- 从某个顶点 $v$ 出发，首先**访问 $v$**。
- 然后，**依次**访问 $v$ **所有**尚未访问的邻接点（比如 $w_1, w_2, ...$）。
- **（关键区别）**：**访问完 $v$ 的所有邻接点后**，再**按顺序**从 $w_1$ 出发，访问 $w_1$ 的所有未访问邻接点；然后再从 $w_2$ 出发，访问 $w_2$ 的... 2。
- 这种“先访问完第1层，再访问第2层，再访问第3层”的特性，天然符合“**先进先出**”（FIFO）的逻辑。
**实现工具：** DFS用栈（Stack），而BFS则需要用**队列 (Queue)** 。

## 实现过程

队列“先进先出”的特性完美地实现了这个过程：
- $v$ 先入队。
- $v$ 出队，我们访问它，并把它所有的邻接点 $w_1, w_2, w_3$ **按顺序**入队。
- $w_1$ 先入队，所以 $w_1$ 先出队。我们访问 $w_1$，并把 $w_1$ 的邻接点入队。
- 接着 $w_2$ 出队... 接着 $w_3$ 出队...
- 这样就保证了第一层的 $w_1, w_2, w_3$ 一定在第二层的所有邻接点**之前**被处理。
C语言具体实现
```c
void BFS(Graph G)
{
    int visited[MAXNODE] = {0};      // 所有顶点都未访问过
    struct ArcNode *temp;
    int i, v;
    SqQueue Q;
    InitQueue(Q);                    // Q 是空队列

	//这是一个外层循环，它的唯一目的是处理非连通图。如果图是连通的，这个循环体内的if只会执行一次。
    for (v = 0; v < G.vexnum; v++) 
    {
        if (visited[v] == 0)         // 顶点 v 未访问
        {
            EnQueue(Q, v);           // 入队
            printf("%d", v);         // 访问
            visited[v] = 1;

            while (!QueueEmpty(Q))
            {
                DeQueue(Q, v);       // v出队
                // 遍历 v 的所有邻接点
                for (temp = G.adjlist[v].firstarc; temp; temp = temp->nextarc)
                {
                    i = temp->adjvex;
                    if (!visited[i])
                    {
                        EnQueue(Q, i);
                        visited[i] = 1;
                        printf("%d", i);
                    }
                }
            }
        }
    }
}
```

## 时间复杂度分析

**时间复杂度 $O(n+e)$（邻接表）**
- 每个顶点 $v$ 都**只入队一次**、**出队一次**（因为有 `visited` 数组）。这是 $O(n)$。
- 在整个过程中（$n$ 次出队），每个顶点的邻接表都**只被遍历一次**（`for` 循环）。
- 所有邻接表加起来总共有 $e$（有向图）或 $2e$（无向图）个边结点。
- 总共：$O(n)$（顶点入/出队）+ $O(e)$（遍历邻接表）= $O(n+e)$ 23。

**时间复杂度 $O(n^2)$（邻接矩阵）**
- $n$ 个顶点入队出队是 $O(n)$。
- **瓶颈：** 当一个顶点 $v$ 出队时，你需要找到它的所有邻接点并且把他们入队。你必须遍历矩阵的**第 $v$ 行**（从 $j=0$ 到 $n-1$），这个操作耗时 $O(n)$。
- 总共有 $n$ 个顶点要出队，所以总时间是 $O(n \times n) = O(n^2)$。

# 生成树

对于一个**连通图**，我们想选出图中的一部分边，把所有 $n$ 个顶点都连接起来，并且不形成任何环路。这个由 $n$ 个顶点和 $n-1$ 条边构成的子图就是一棵“生成树”

**遍历与生成树的关系：**
- 当我们从某个起点 $v$ 开始进行图的遍历（DFS或BFS）时，我们会“发现”新的、未被访问过的顶点。
- 那些在遍历过程中**第一次**“发现”新顶点时所经过的边，就被称为“**树边**”（Tree Edge）。
- 将一个连通图的所有顶点和所有的“树边”组合起来，就构成了一棵以 $v$ 为根的树，这就是**遍历生成树**。

- **核心区别：**
    - **DFS** 采用“深度优先”策略（递归/栈），它会尽可能深地“钻”下去。因此，它选出的“树边”会倾向于**形成一条长链**。
    - **BFS** 采用“广度优先”策略（队列/层次），它会先访问完一层所有的邻居。因此，它选出的“树边”会倾向于**形成一个“矮胖”的结构**。
- **重要特性：** 对于同一个图，从同一个起点出发，根据你**访问邻接点的顺序**不同，你得到的DFS或BFS生成树都可能**不是唯一**的 。
### **DFS生成树：**

- **定义：** 在连通图上，DFS遍历过程中所经过的**实线箭头**（即发现新顶点的边）构成的树 。
- **形态特征：** 树的**深度通常较大**，形态上“**高而瘦**”，反映了DFS的==递归调用栈深度==。
## **BFS生成树：**

- **定义：** 在连通图上，BFS遍历过程中所经过的**箭线**（即发现新顶点的边）构成的树 。
- **形态特征：** 树的**深度通常较小**，形态上“**矮而胖**”，反映了BFS的层次遍历特性。
- **核心应用：** ==BFS生成树从根到任意节点 $w$ 的路径，**一定是**原图中从根到 $w$ 的**无权最短路径**（即经过边数最少的路径）==。