有多种存储方法，数组表示法，邻接表，十字链表
# 邻接矩阵法（数组表示法）

邻接矩阵，顾名思义，就是用一个**矩阵（二维数组）** 来存储图中各个顶点之间的关系（也就是边或弧)。

我们假设图有 $n$ 个顶点，我们就可以用一个 $n \times n$ 的方阵 $A$ 来表示。

对于没有权重的图（无论是无向图还是有向图）：

$$A[i][j] = \begin{cases} 1 & \text{若}(v_i, v_j) \text{ 或 } <v_i, v_j> \text{ 存在} \\ 0 & \text{若不存在} \end{cases}$$

对于带权重的图（“网”）：
$$A[i][j] = \begin{cases} w_{ij} & \text{若边存在} \\ \infty & \text{若边不存在} \end{cases}$$
- **注意：** 课件上提到，根据实际情况，这个 $\infty$ 也可以用 **0** 来表示 
- 例如，在一个权重都为正数的图中，用0来表示“无边”也是一种常见做法)。


![[Pasted image 20251104212117.png]]
- **对称性**：邻接矩阵**必定是对称矩阵**（即 $A[i][j] = A[j][i]$）。
- **求度数**：顶点 $v_i$ 的**度** = 第 $i$ 行（或第 $i$ 列）中非零元素的个数。
- **求边数**：**总边数 $e$** = 矩阵中所有非零元素个数的**一半**。


![[Pasted image 20251104212131.png]]

- **非对称性**：**非对称性**：A->B有弧 ($A[0][1]=1$)，但 B->A 没有弧 ($A[1][0]=0$)。矩阵是**不对称**的。
- **求度数**：
    - $v_i$ 的 **出度**  = 第 $i$ **行** 中非零元素的个数。
    - $v_i$ 的 **入度** = 第 $i$ **列** 中非零元素的个数。
- **求弧数**：图的总**弧数** = 矩阵中所有非零元素的个数。

C语言中的具体实例
```C
#define MAXNODE <最大顶点数>
typedef char vextype;  // 顶点信息的类型
typedef int adjtype;   // 边上权值的类型

typedef struct {
    vextype vexs[MAXNODE];                 // 存放顶点信息的一维数组
    adjtype adjMatrix[MAXNODE][MAXNODE]; // 邻接矩阵（二维数组）
    int vexnum, arcnum;                    // 图的当前顶点数和弧（边）数
} Graph;
```

- `vexs` 数组：用来存储像 'A', 'B', 'C' 这样的顶点信息。
- `adjMatrix` 数组：就是我们前面讲的 $n \times n$ 矩阵，用来存 0/1 或权重。
- `vexnum` 和 `arcnum`：用来记录图的规模。
#### 例 键盘输入顶点信息和边的信息，创建n个顶点的无向网。

```C
int CreatGraph(Graph *&ga)  // 返回 OK 表示创建成功
{
    int i, j, m, weight;
    /* 读入顶点信息，建立顶点表 */
    for (i = 0; i < ga->vexnum; i++)
        scanf("%d", &ga->vexs[i]);
    /* 邻接矩阵初始化 */
    for (i = 0; i < ga->vexnum; i++)
        for (j = 0; j < ga->vexnum; j++)
            ga->adjMatrix[i][j] = 0;
    /* 读入边 */
    for (m = 0; m < ga->arcnum; m++)
    {
        scanf("%d%d%d", &i, &j, &weight);  // 读入边 (vi,vj) 上的权值
        ga->adjMatrix[i][j] = weight;
        ga->adjMatrix[j][i] = weight;      // 无向网，矩阵对称
    }
    return OK;
}
```
**时间复杂度分析**：
- 读顶点是 $O(n)$。
- 初始化矩阵是 $O(n^2)$。
- 读 $e$ 条边是 $O(e)$。
- 总时间是 $O(n + n^2 + e)$。
- 在稠密图中 $e$ 接近 $n^2$；在稀疏图中 $e$ 远小于 $n^2$。但无论如何，**$O(n^2)$ 的初始化是无法避免的**，所以总时间复杂度为 $O(n^2)$ 。
## **邻接矩阵的优缺点**：

- **优点**：
    - **查询快**：判断 $v_i$ 和 $v_j$ 之间是否有边 (或获取权值)，只需要 $O(1)$ 时间 (直接访问 `A[i][j]`)。
    - **计算度快 (有向图)**：计算出度 (扫一行) 或入度 (扫一列) 都是 $O(n)$。
    - **实现简单**：就是二维数组。
- **缺点**：
    - 浪费空间：对于稀疏图（$e$ 远小于 $n^2$），矩阵中
        绝大部分都是 0 或 $\infty$，造成巨大空间浪费 。
    - **统计邻接点慢**：要找到 $v_i$ 的**所有**邻接点，必须遍历第 $i$ 行，时间是 $O(n)$，即使 $v_i$ 只有一个邻接点。
    - **空间复杂度固定**：空间总是 $O(n^2)$，与 $e$ 的多少无关 。

# 邻接表

- **邻接矩阵的痛点**：空间复杂度固定为 $O(n^2)$ 。如果一个图有10000个顶点，但只有5000条边（稀疏图），邻接矩阵会浪费大量空间来存储 0 或 $\infty$。

- **邻接表的解决方案**：**只存储存在的边**。
- 我们使用一个**数组**（大小为 $n$），每个元素对应一个**顶点**（称为“头结点”）。
- 对于每个顶点 $v_i$ （即数组的第 $i$ 个元素），我们用一个**单链表**把它所有**邻接**的边（或弧）都串起来 。
- 因此，邻接表是一种“**数组 + 链表**”的组合结构 。


## **头结点数组：

- 这是一个**数组**，图中有多少个顶点，数组就有多大。
- 数组的**第 $i$ 个元素**代表顶点 $v_i$ 。
- 这个头结点（`VNode`）包含：
    - `data`：存储顶点 $v_i$ 的信息（比如'A', 'B', 'C'）。
    - `firstarc`：一个**指针**，指向 $v_i$ 的“边链表”中的**第一个**边结点。如果 $v_i$ 没有出边，它就是NULL。

## **边表链表：

- `firstarc` 指针指向的是一个**单链表** 。
- 链表中的每一个结点（`ArcNode`）代表一条**边**（或弧）。
- 在有向图中，这个链表存储的是**以 $v_i$ 为尾（起点）的弧**。
- 这个边结点（`ArcNode`）包含：
    - `adjvex`：该边指向的顶点的**数组下标** 。
    - `info`：边的信息，比如**权值** 。
    - `nextarc`：一个**指针**，指向**同一顶点出发**的**下一条**边结点。
![[Pasted image 20251104213704.png]]

## 邻接表的特性

### 不唯一性：
- **为什么？** 看 $v_0$ 的边链表，它有三条出边（到 $v_1, v_2, v_3$）。在创建这个链表时，我完全可以把“到 $v_2$ ”的结点放第一位，也可以把“到 $v_3$ ”的放第一位。
- 插入的顺序不同，会导致链表的形态不同，但它们表示的是**同一个图**。而邻接矩阵，只要顶点编号固定，$A[0][1]$ 的值永远是固定的。

### 空间复杂度 $O(n+e)$:
- **为什么？** 存储空间 = (头结点数组) + (所有边表结点)。
- 头结点数组：固定 $n$ 个。
- 边表结点：
    - **有向图**：每条弧 $<u, v>$ 对应**一个**边表结点（挂在 $u$ 的链表上）。总共 $e$ 个。
    - **无向图**：每条边 $(u, v)$ 对应**两个**边表结点（一个挂在 $u$ 的链表上，表示 $u \to v$；一个挂在 $v$ 的链表上，表示 $v \to u$）。总共 $2e$ 个。
- 所以总空间是 $O(n+e)$ 或 $O(n+2e)$，统一为 $O(n+e)$

## **操作复杂度（邻接表 VS 邻接矩阵）：**

- **查询边 $(u, v)$ 是否存在？**
    - 邻接表：$O(\text{deg}(u))$。你需要遍历 $u$ 的链表，看 $v$ 在不在里面。
    - 邻接矩阵：$O(1)$。直接查 `A[u][v]`。

- **遍历 $u$ 的所有邻接点？**
    - 邻接表：$O(\text{deg}(u))$。只需遍历 $u$ 的链表。
    - 邻接矩阵：$O(n)$。你需要遍历矩阵的第 $u$ **整行**。
- **结论：** 邻接表牺牲了 $O(1)$ 的边查询速度，换取了 $O(n+e)$ 的空间和高效的邻接点遍历。

# 逆邻接表

- 邻接表是“第 $i$ 个链表存储 $v_i$ **出发**的弧” ，这导致：求 $v_i$ 的**出度**（Out-degree）很容易，数第 $i$ 个链表的长度就行。
- 但求 $v_i$ 的**入度**（In-degree）呢？你必须遍历**所有 $n$ 个**头结点，再遍历它们**所有 $e$ 个**边结点，看谁的 `adjvex` 等于 $i$。这太慢了，复杂度 $O(n+e)$

-  “逆邻接表”就是把邻接表反过来。第 $i$ 个链表存储**指向** $v_i$ 的弧。
	有了它，求 $v_i$ 的**入度**就和求出度一样快了，都是 $O(\text{deg}_{in}(v_i))$

# 十字链表

这个结构专门用于**有向图**，用来解决邻接表求“入度”困难的问题。它是邻接表和逆邻接表的结合。


## 顶点结点 (Head Node)

- `firstout` ：**出度链表的头**。它指向以该顶点为**起点**（Tail）的第一条弧。
- `firstin` ：**入度链表的头**。它指向以该顶点为**终点**（Head）的第一条弧。
## 边结点 (Edge Node)

- `tailvex`, `headvex`：分别记录这条弧的**起点下标**和**终点下标**。
- `tlink` (tail link) ：**出度链表的指针**。它指向**下一条**具有**相同起点**（`tailvex`）的弧。
- `hlink` (head link) ：**入度链表的指针**。它指向**下一条**具有**相同终点**（`headvex`）的弧。



