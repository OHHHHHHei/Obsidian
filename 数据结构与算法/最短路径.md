# 单源最短路径问题
- **给定**：一个有向网 $G$（带权的有向图）和一个源点 $v$ 。
- **目标**：求从源点 $v$ 到图 $G$ 中其余所有顶点的最短路径，以及这条路径的长度。
## 重要约束：
课件特别标注了 “限定各边上的权值大于或等于 0。
- 这是 Dijkstra 算法生效的数学基础。Dijkstra 基于“贪心”策略，它假设当你通过一条边走得更远时，路径长度只会增加或不变（因为权值非负），绝对不会变短。如果存在负权边，后续讲解的“贪心选择”逻辑就会失效（这一点在最后 PPT 第 14 页会再次验证）。
## Dijkstra 算法核心思想：
算法是按路径长度递增的次序产生最短路径的。这意味着我们总是先找到离起点最近的那个点，然后再往外扩。

![[Pasted image 20251125174527.png]]
- **路径与费用的计算**：
    - 路径费用定义：旅行路线总费用 = 路上所有有向边的权之和。
        数学公式可表示为：$Cost(P) = \sum_{e \in P} w(e)$。
    - 案例分析：
        课件展示了两条从 $v_1$ 到 $v_8$ 的路径作为对比：
        1. **路径 $P_1$**（图中上方路径）：
            - 路线：$v_1 \rightarrow v_2 \rightarrow v_5 \rightarrow v_8$。
            - 计算推导：$6 (\text{edge } v_1v_2) + 1 (\text{edge } v_2v_5) + 6 (\text{edge } v_5v_8) = 13$。
        2. **路径 $P_2$**（图中下方路径）
            - 路线：$v_1 \rightarrow v_3 \rightarrow v_4 \rightarrow v_6 \rightarrow v_7 \rightarrow v_8$ 10
            - 计算推导：$3 + 2 + 10 + 4 + 4 = 23$ 11。
- 结论：
    虽然 $P_1$ 看起来只经过了 3 条边，而 $P_2$ 经过了 5 条边，但 $P_1$ 的权值和（13）小于 $P_2$（23）。因此在这两者中，$P_1$ 更优。
    - 在带权图中，**“最短”指的是数学上的加权和最小**，而不是拓扑结构上的边数最少（那是 BFS 广度优先搜索解决的问题）。
# Dijkstra 算法的求解思路与详细步骤

- **集合 S (Sorted/Selected)**：
    - **定义**：已求出最短路径的终点集合。
    - **初始状态**：只包含源点 $v$，即 $S=\{v\}$。因为源点到自己的距离显然是0。
    - **终态**：包含图中所有顶点。
- **集合 U (Unsorted/Unvisited)**：
    - **定义**：其余未求出最短路径的顶点集合。
    - **关系**：$U = V - S$（图的所有顶点减去 S 中的顶点）。
- **当前最短路长 (`dist[i]`) 的特殊定义**：
    - 在算法运行过程中，对于 U 中的顶点 $i$，我们维护一个距离值 `dist[i]`。
    - **关键约束**：这个距离不仅仅是“任意路径”，而是指 **“从源点到顶点 $i$ 的、中间只经过 S 中的顶点”** 的最短路径长度。
    - 为什么要加“中间只经过 S”这个限制？因为 S 中的点是我们已经确定的“安全点”，我们可以放心地利用它们作为中转站。
## 详细步骤
### 1. 初始化
- **S 集**：$S = \{v\}$（只含源点）。
- **U 集**：包含除 $v$ 以外的所有其他顶点。
- **距离数组 `dist[]`**：
    - 源点 `dist[v] = 0`。
    - 对于 U 中的点 $i$：
        - 如果源点 $v$ 与 $i$ 直接相连，则 `dist[i] =` 边上的权值。
        - 如果不相连，则 `dist[i] = \infty`（无穷大）。
### 2. 选择
**贪心策略的体现**
- **操作**：从 U 集合中扫描，找出一个顶点 $u$，使得 `dist[u]` 是 U 中最小的。
- **动作**：将这个 $u$ 加入到 S 集合中。
- 为什么这样做？：
    这是 Dijkstra 最精妙的地方。因为边权非负，如果 $u$ 是当前 U 中距离源点最近的点，那么不可能存在另一条路径“绕道”U 中的其他点再回到 $u$ 还会比当前更短。所以，此刻选出的 $u$ 的最短路径就已经确定了！
### 3. 修正
- **操作**：以刚加入 S 的顶点 $u$ 为“中间点”（跳板），检查 U 中剩余的每个顶点 $j$。
- **判断逻辑**：
    - 我们有两条路去往 $j$：
        1. 原来的路：长度为 `dist[j]`（不经过 $u$）。
        2. 新发现的路：从源点走到 $u$，再从 $u$ 走到 $j$。长度为 `dist[u] + w_{uj}`。
公式
$$dist[j] = \min(dist[j], \;\; dist[u] + w_{uj})$$
- 如果 $dist[u] + w_{uj} < dist[j]$，说明我们找到了一条更近的路，于是更新 `dist[j]`。
- 这在计算机科学中被称为 **松弛（Relaxation）** 操作。
### 4.循环
重复步骤 (2) 和 (3)，直到 U 集合为空（所有顶点都加入了 S）。
# 路径还原

- **核心逻辑**：`path[]` 数组存储的是 **“前驱节点”**。
    - `path[i] = k` 的含义是：在最短路径中，到达顶点 $i$ 之前的那个点是 $k$。
- **推导方向**：**逆向推导**。从终点出发，找它的前驱，再找前驱的前驱，一直追溯到源点。
- **数据结构思想**：这种“逆向链表”的结构非常适合用栈（Stack）来存储，输出时再弹栈就能得到正向路径。
# 代码实现
- **数据结构准备**：
    - 图用 **邻接矩阵** `arcs[][]` 表示。
    - `dist[i]`：记录当前最短路径长度。
- **初始化**：
    - 集合 S 初始只包含源点 $v$ 。
    - `dist` 数组初始化为源点到各邻居的直接距离。
- **主循环 (Main Loop)**：
    - `for (i=0; i < n-1; i++)` 4：
        - 因为一共有 $n$ 个顶点，源点已在 S 中，所以只需要处理剩下的 $n-1$ 个顶点，循环 $n-1$ 次。
- **循环内部操作**：
    1. **选择 (Select)**：
        - 在 U 中选择一个顶点 u，满足 $dist[u]$  最短 。
        - **操作**：扫描一遍 U 列表，找到最小值。
    2. **加入集合 (Add)**
        - 将顶点 u 加入到集合 S 中。
    3. **松弛 (Relax - 核心)**：
        - 对于每个属于 U 的顶点 j，检查是否需要更新 。
        - **判断条件**：`if (dist[j] > dist[u] + arcs[u][j])` 。
        - **更新动作**：`dist[j] = dist[u] + arcs[u][j]`。
- **时间复杂度分析**：
    - 外层循环执行 $n-1$ 次。
    - 内层“找最小”需要扫描所有点（$O(n)$）。
    - 内层“松弛”需要扫描所有邻居（最坏 $O(n)$）。
    - 总复杂度：$(n-1) \times (n + n) \approx O(n^2)$ 。
# 思考
- **思考 1：单终点问题**
    - **问题**：如果我只想要从源点 $v$ 到某一个特定终点 $k$ 的最短路径，能用 Dijkstra 吗？
        - **能用**。只需要在代码中加一个判断：当“选择”步骤中选出的顶点 $u$ 恰好就是终点 $k$ 时，算法可以**提前终止**（Break）。
        - **复杂度**：虽然可以提前停，但在最坏情况下（比如 $k$ 是离源点最远的那个点），我们依然需要遍历所有节点。所以时间复杂度**依然是 $O(n^2)$**。
- **思考 2：负权边的死穴
    - **场景**：PPT 左图展示了一个三角形图：
        - $v_1 \rightarrow v_2$ 权值为 3。
        - $v_1 \rightarrow v_3$ 权值为 2。
        - $v_2 \rightarrow v_3$ 权值为 **-2** (负权边)。
    - **Dijkstra 的错误执行过程**：
        1. **第一步（初始化）**：$S=\{v_1\}$。$dist[v_2]=3$, $dist[v_3]=2$。
        2. **第二步（选择）**：在 $v_2$ (3) 和 $v_3$ (2) 中选最小。
            - 算法选择了 **$v_3$**，因为它距离 2 最小。
            - **关键错误发生点**：Dijkstra 算法一旦把顶点加入 S，就认为**它的最短路径已经确定了，永不回头修改**。所以算法判定 $v_1 \to v_3$ 的最短距离是 **2**。
        3. **真实情况**：
            - 如果我们走 $v_1 \rightarrow v_2 \rightarrow v_3$，总长度是 $3 + (-2) = \textbf{1}$。
            - 显然 $1 < 2$，真实的最短路径应该是经过 $v_2$ 的那条。
    - **结论**：因为 Dijkstra 贪心地选择了直接相连的 $v_3$，而忽略了可能存在一条“虽然先走得远一点（到 $v_2$ 是 3），但后面可以通过负权边把距离减回来”的路径。所以，**Dijkstra 无法正确求解带负权边的图**。