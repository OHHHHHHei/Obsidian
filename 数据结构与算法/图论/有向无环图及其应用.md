# 有向无环图与 AOV网

## 有向无环图（directed acycline graph, DAG）
是描述一项工程或系统的进行过程的有效工具。 一个大的工程项目可划分成若干个较小的子工程，这些子工程称为**活动** 。
当所有活动完成时，整个工程也就相应完成。有些活动存在先后次序关系。 
例如，汽车装配工程可以分解为以下任务：将底盘放到装配线上、安装车轴、安装车轮、将座位装在底盘上、喷漆、装刹车、装车门等等。而且任务之间具有先后关系，例如在安装车轴之前必须先将底盘放到装配线上。 

- **工程应用背景**：为了描述一项大工程（如造车、盖楼），我们需要将其拆分为许多子活动 。

- **数学建模**：用“顶点”代表活动，用“有向边”代表活动的先后次序，这就形成了 **AOV网 (Activity On Vertex Network)** 。

- **约束条件**：工程不能死循环（例如A等B，B等A），因此AOV网中**不能存在有向环**，这就是 **有向无环图 (DAG)** 的由来 。

### 两个问题： 
- 工程能否顺利进行？（即：是否存在环？） $\rightarrow$ **拓扑排序**。
    
- 工程完成的最短时间是多少？ $\rightarrow$ **关键路径**（本节课重点在拓扑排序）。

## AOV网

### **概念**：
在有向图中，如果**顶点**表示活动，**有向边** $<V_i, V_j>$ 表示活动 $V_i$ 必须先于 $V_j$ 进行，这种图称为 AOV 网。
### **现实案例**：
**盖楼**：你必须先“建造地基 (A7)”，才能“建造楼房 (A8)”。不可能反过来，这就形成了先后关系。
![[Pasted image 20251118204750.png]] 

**排课**：这也是你们最熟悉的。比如要学《数据结构 (C4)》，必须先学《程序设计基础 (C2)》和《离散数学 (C3)》。
![[Pasted image 20251118204809.png]] 
### 为什么不能有环？

如果图中存在环，比如 $A \rightarrow B \rightarrow C \rightarrow A$，意味着 A 的发生依赖于 B，B 依赖于 C，而 C 又依赖于 A。这在逻辑上构成了死锁（Deadlock），工程将永远无法开始。因此，AOV网必须是 DAG (Directed Acyclic Graph) 。
# 拓扑结构

## **目标**：

把一个复杂的网状结构，压扁成一个线性的、有序的序列 。
## **规则**：

如果图中有一条边从 $V_i$ 指向 $V_j$，那么在线性序列中，$V_i$ 必须排在 $V_j$ 的前面 。
## 性质

拓扑序列**不唯一**。对于之间没有依赖关系的顶点，谁先谁后都可以（例如图中的 $C_1$ 和 $C_2$ 互不依赖，谁排前面都行）。

**充要条件**：一个图能进行拓扑排序 $\iff$ 该图是有向无环图 (DAG)。

数学定义推导

拓扑排序是将有向图 $G=(V, E)$ 的所有顶点排成一个线性序列 $v_1, v_2, ..., v_n$，满足：

$$\forall <v_i, v_j> \in E \implies \text{在序列中 } v_i \text{ 出现在 } v_j \text{ 之前}$$
# 贪心算法

- 我们如何找到这个拓扑序列？甚至如何编写代码实现？

- 引入 **贪心策略**：总是做出当前看起来最好的选择，即“局部最优” 。

- **映射到拓扑排序**：什么叫“当前最好”？就是那些**没有前驱依赖**（入度为0）的顶点，它们现在就可以立即执行 。

- **核心思想**：
	
    - **“目光短浅”**：在解决问题的每一步中，都做出在**当前看来是最好的选择**（局部最优解）。
    - **“不可回头”**：一旦做出了选择，就不能改变。它不进行回溯（不像 DFS 那样撞了南墙回头），而是一条路走到黑 。
    

**可以用贪心法解决的问题必须具备以下两个性质：** 

- 贪心选择性质 
- 最优子结构性质
### 贪心选择性质 (Greedy Choice Property)
#### 通俗定义：
当你面临多个选择时，你仅仅依据当前的信息做出一个在当前看来最好的选择（局部最优），这个选择一定包含在最终的全局最优解中。也就是说，你现在的“贪婪”选择，在未来绝对不会让你后悔。
#### 为什么必须具备？
因为贪心算法不回溯（不走回头路）。如果这一步选错了，后面再怎么努力也挽回不了。只有当“当前的局部最优”确实能导向“全局最优”时，贪心法才成立。

**举例说明**：

**拓扑排序：** 
- 你现在的选择是“入度为0”的课 $C_1$。选了它，会不会导致后面无法排课？不会。选入度为0的课永远是安全的、正确的。所以它具备贪心选择性质。

**不成立的情况（找零钱反例）**：
- **场景**：要找15分钱，硬币有 $\{11, 5, 1\}$。
- **贪心选择**：当前最大的是11，我贪心，选了11。
- **后果**：剩下的4分钱只能用4个1分。总共 $1+4=5$ 枚硬币。
- **实际最优**：应该是 $5+5+5$，只要3枚。
- **分析**：这里的第一步“贪心选择”（选11）**并不包含**在全局最优解（全是5）中。一旦你贪了那个11，你就注定得不到最优解了。这就是**不具备**贪心选择性质。
### 最优子结构性质 (Optimal Substructure Property)
#### 通俗定义：
一个问题的最优解，包含了其子问题的最优解。

这意味着，当你做出了第一个贪心选择后，原问题就变成了一个规模更小、但结构相同的子问题。只要你能把这个子问题解好，加上刚才的第一步，就是全局最优解。
#### 为什么必须具备？

这保证了我们可以用循环或递归的方式持续进行贪心。如果不具备这个性质，你解完第一步，剩下的烂摊子可能完全变成了另一种无法处理的问题，或者剩下的部分即使解到最好，拼起来也不是整体最好。
#### **举例说明**：

**成立的情况（最短路径）：** 

- 假设从北京到广州的最短路径经过武汉（北京 $\to$ 武汉 $\to$ 广州）。
- 那么，这条路径中的“北京 $\to$ 武汉”这一段，一定也是北京到武汉之间的最短路径。
- 如果“北京 $\to$ 武汉”有更短的路，我们要么会走那条更短的，要么现在的整体路径就不是最短的。这就叫最优子结构。
- 因此，我们可以放心地一段一段去找最短路。

**拓扑排序中的体现：** 
原图 $G$ 中，我们选了 $C_1$（入度0）并删除它。
子问题：剩下的图 $G'$ 也是一个 AOV 网，我们需要对 $G'$ 进行拓扑排序。
只要 $G'$ 的拓扑序列是合法的，把它接在 $C_1$ 后面，整体序列就是合法的。这就是最优子结构。
## **贪心算法的本质**

- **找零问题例子**：
- 你要找给别人70分钱，希望硬币数量最少。
- **贪心策略**：每次都拿面值最大的硬币（只要不超过总额）。
- 步骤：拿25 $\to$ 剩45；再拿25 $\to$ 剩20；拿10 $\to$ 剩10；再拿10 $\to$ 完成。
- 这就是贪心：每一步都选“最大”，最后得到全局解。
- **注意**：贪心法不一定总能得到全局最优解（如课件中找零问题II的情况），但在**拓扑排序**这个问题上，贪心策略是完全正确且高效的。
## 拓扑排序的贪心策略

这是我们写代码的伪代码逻辑：
1. **选择 (Select)**：在当前的剩余图中，寻找一个 **入度为0** 的顶点 $V$。
	- 解释：入度为0意味着它的所有前置任务都已完成，或者它本来就没有前置任务
2. **删除 (Remove)**：从图中“摘除”顶点 $V$，并且把由 $V$ 发出的所有边也剪断。
    - _解释_：$V$ 做完了，那么依赖 $V$ 的那些后续任务，它们的等待条件就减少了一个（即后续节点的入度 - 1）。
3. **循环 (Loop)**：重复以上步骤。
# 数据结构的设计
要实现“找入度为0 -> 删除 -> 再找”的过程，我们需要对标准的图结构做一点小改造。
- **增加“入度域” (count)**：
    - **逻辑**：在标准的邻接表表头结点（Vertex Node）中，增加一个整数域 `count` 。
    - **作用**：用来实时记录该顶点当前的入度。当 `count` 变为 0 时，说明它变成了一个“候选顶点”，可以输出了 。
```c
typedef struct {
    ElemType data;      // 顶点信息
    int count;          // 【新增】存放顶点入度
    Node *firstarc;     // 指向第一条边
} VNode;
```
- **引入“栈” (Stack)**：
    - **逻辑**：我们需要一个容器来暂存那些“入度为0”但还没来得及处理的顶点 。
    - **为什么用栈？**：方便操作（LIFO）。其实用队列（Queue）也可以，效果一样，只是输出顺序不同。课件中使用的是栈 `St[MAXV]` 。
## **阶段一：计算初始入度 (预处理)** 
这是因为邻接表只方便找“出边”，不方便找“入边”，所以必须先遍历一遍全图算入度。
```c
// 1. 初始化所有 count 为 0
for (i=0; i < G->vexsnum; i++)
    G->adjlist[i].count = 0;

// 2. 遍历全图，计算每个顶点的实际入度
for (i = 0; i < G->vexsnum; i++) {
    p = G->adjlist[i].firstarc;
    while (p != NULL) {
        // p->adjvex 是顶点 i 指向的邻居 j
        // 既然 i 指向 j，那么 j 的入度就 +1
        G->adjlist[p->adjvex].count++;
        p = p->nextarc;
    }
}
```
## **阶段二：寻找第一批候选者 (入栈)** 扫描所有顶点，把一开始就没有前驱的顶点扔进栈里。
```c
for (i=0; i<G->vexsnum; i++)
    if (G->adjlist[i].count == 0) { // 找到入度为0的点
        top++;
        St[top] = i; // 入栈
    }
```
## **阶段三：循环处理 (贪心策略的核心)** 这是算法的主循环，对应我们之前说的“输出并删除”过程。
```c
while (top > -1) { // 只要栈不空，就继续做
    // 1. 【输出】弹出栈顶元素 i，并打印
    i = St[top];
    top--;
    printf("%d ", i);

    // 2. 【删除】逻辑上删除顶点 i 发出的所有边
    // 即：找到 i 的所有邻接点 j，把它们的入度减 1
    p = G->adjlist[i].firstarc;
    while (p != NULL) {
        j = p->adjvex;
        G->adjlist[j].count--; // 邻接点入度减 1

        // 3. 【再找】贪心判断：减完之后，如果 j 的入度变成了 0
        // 说明 j 的所有前驱都搞定了，j 也可以入栈了！
        if (G->adjlist[j].count == 0) {
            top++;
            St[top] = j;
        }
        p = p->nextarc;
    }
}
```
## 复杂度和常见考点
### **时间复杂度**
- **基于邻接表：
    - **分析**：
        1. 初始化入度：我们需要遍历所有的边来计算入度。时间是 $O(e)$。
        2. 入栈/出栈操作：每个顶点进出栈一次。时间是 $O(n)$。
        3. 减入度操作：在主循环中，我们会遍历每个顶点的所有邻边。总共还是遍历了所有的边。时间是 $O(e)$。
    - **结论**：总时间复杂度为 **$O(n+e)$**。这是一个非常高效的线性算法。
## **判断有环**
- **考点**：如果 `while` 循环结束后，输出的顶点数 < 图的总顶点数，说明了什么？
- **答案**：说明图中有环（Loop）。剩余的顶点入度都不为 0，形成了死锁，永远进不了栈。
# 基于 DFS 的拓扑排序
在使用 DFS 遍历图时，一个顶点只有在**它的所有邻接点（后继任务）都被访问完之后**，该顶点的递归调用才会结束（我们称为“回溯”或“Finish”）。
- 直观理解：
    假设 $A \to B$（A依赖B）。
    DFS 从 A 开始 $\to$ 发现 B $\to$ 递归进入 B $\to$ B 没有后继了 $\to$ B 先结束递归 $\to$ 回到 A $\to$ A 后结束递归。
- 结论：
    在 DFS 中，最晚完成递归的那个点，其实是拓扑序列中最靠前的点（因为它依赖别人，别人都得先跑完，它才最后收尾；但在拓扑序中，它是“源头”）。
    $A \to B$。我们要的序列是 $A, B$。
    DFS访问顺序：先进A，再进B。
    DFS结束顺序（退出栈的顺序）：先 B 退出，后 A 退出。
    发现规律了吗？
    DFS 结束顺序是 $B, A$（子节点在前，父节点在后）。
    拓扑序列是 $A, B$（父节点在前，子节点在后）。
    所以： DFS 结束顺序的“逆序”，就是拓扑序列！
### 算法步骤
我们可以利用一个 **栈 (Stack)** 来实现这个“逆序”过程
1. **初始化**：准备一个栈 `ResultStack`，以及一个 `visited` 数组标记是否访问过。
2. **遍历**：对图中每一个未访问的顶点调用 DFS 函数。
3. **DFS函数逻辑**：
    - 标记当前顶点 $u$ 为“已访问”。
    - 递归访问 $u$ 的所有未被访问的邻接点（一直往深处走）。
    - **关键点**：当 $u$ 的所有邻居都访问完了（也就是 $u$ 的递归要这就结束了），**把 $u$ 压入栈 `ResultStack`**。
4. **输出**：所有点遍历完后，依次**弹出栈顶元素**，得到的序列就是拓扑序列。