# 单源最短路径问题
- **给定**：一个有向网 $G$（带权的有向图）和一个源点 $v$ 。
- **目标**：求从源点 $v$ 到图 $G$ 中其余所有顶点的最短路径，以及这条路径的长度。
## 重要约束：
课件特别标注了 “限定各边上的权值大于或等于 0。
- 这是 Dijkstra 算法生效的数学基础。Dijkstra 基于“贪心”策略，它假设当你通过一条边走得更远时，路径长度只会增加或不变（因为权值非负），绝对不会变短。如果存在负权边，后续讲解的“贪心选择”逻辑就会失效（这一点在最后 PPT 第 14 页会再次验证）。
## Dijkstra 算法核心思想：
算法是按路径长度递增的次序产生最短路径的。这意味着我们总是先找到离起点最近的那个点，然后再往外扩。

![[Pasted image 20251125174527.png]]
- **路径与费用的计算**：
    - 路径费用定义：旅行路线总费用 = 路上所有有向边的权之和。
        数学公式可表示为：$Cost(P) = \sum_{e \in P} w(e)$。
    - 案例分析：
        课件展示了两条从 $v_1$ 到 $v_8$ 的路径作为对比：
        1. **路径 $P_1$**（图中上方路径）：
            - 路线：$v_1 \rightarrow v_2 \rightarrow v_5 \rightarrow v_8$。
            - 计算推导：$6 (\text{edge } v_1v_2) + 1 (\text{edge } v_2v_5) + 6 (\text{edge } v_5v_8) = 13$。
        2. **路径 $P_2$**（图中下方路径）
            - 路线：$v_1 \rightarrow v_3 \rightarrow v_4 \rightarrow v_6 \rightarrow v_7 \rightarrow v_8$ 10
            - 计算推导：$3 + 2 + 10 + 4 + 4 = 23$ 11。
- 结论：
    虽然 $P_1$ 看起来只经过了 3 条边，而 $P_2$ 经过了 5 条边，但 $P_1$ 的权值和（13）小于 $P_2$（23）。因此在这两者中，$P_1$ 更优。
    - 在带权图中，**“最短”指的是数学上的加权和最小**，而不是拓扑结构上的边数最少（那是 BFS 广度优先搜索解决的问题）。
## Dijkstra 算法的求解思路与详细步骤

- **集合 S (Sorted/Selected)**：
    - **定义**：已求出最短路径的终点集合。
    - **初始状态**：只包含源点 $v$，即 $S=\{v\}$。因为源点到自己的距离显然是0。
    - **终态**：包含图中所有顶点。
- **集合 U (Unsorted/Unvisited)**：
    - **定义**：其余未求出最短路径的顶点集合。
    - **关系**：$U = V - S$（图的所有顶点减去 S 中的顶点）。
- **当前最短路长 (`dist[i]`) 的特殊定义**：
    - 在算法运行过程中，对于 U 中的顶点 $i$，我们维护一个距离值 `dist[i]`。
    - **关键约束**：这个距离不仅仅是“任意路径”，而是指 **“从源点到顶点 $i$ 的、中间只经过 S 中的顶点”** 的最短路径长度。
    - 为什么要加“中间只经过 S”这个限制？因为 S 中的点是我们已经确定的“安全点”，我们可以放心地利用它们作为中转站。
## 详细步骤
### 1. 初始化
- **S 集**：$S = \{v\}$（只含源点）。
- **U 集**：包含除 $v$ 以外的所有其他顶点。
- **距离数组 `dist[]`**：
    - 源点 `dist[v] = 0`。
    - 对于 U 中的点 $i$：
        - 如果源点 $v$ 与 $i$ 直接相连，则 `dist[i] =` 边上的权值。
        - 如果不相连，则 `dist[i] = \infty`（无穷大）。
### 2. 选择
**贪心策略的体现**
- **操作**：从 U 集合中扫描，找出一个顶点 $u$，使得 `dist[u]` 是 U 中最小的。
- **动作**：将这个 $u$ 加入到 S 集合中。
- 为什么这样做？：
    这是 Dijkstra 最精妙的地方。因为边权非负，如果 $u$ 是当前 U 中距离源点最近的点，那么不可能存在另一条路径“绕道”U 中的其他点再回到 $u$ 还会比当前更短。所以，此刻选出的 $u$ 的最短路径就已经确定了！
### 3. 修正
- **操作**：以刚加入 S 的顶点 $u$ 为“中间点”（跳板），检查 U 中剩余的每个顶点 $j$。
- **判断逻辑**：
    - 我们有两条路去往 $j$：
        1. 原来的路：长度为 `dist[j]`（不经过 $u$）。
        2. 新发现的路：从源点走到 $u$，再从 $u$ 走到 $j$。长度为 `dist[u] + w_{uj}`。
公式
$$dist[j] = \min(dist[j], \;\; dist[u] + w_{uj})$$
- 如果 $dist[u] + w_{uj} < dist[j]$，说明我们找到了一条更近的路，于是更新 `dist[j]`。
- 这在计算机科学中被称为 **松弛（Relaxation）** 操作。
### 4.循环
重复步骤 (2) 和 (3)，直到 U 集合为空（所有顶点都加入了 S）。
## 路径还原

- **核心逻辑**：`path[]` 数组存储的是 **“前驱节点”**。
    - `path[i] = k` 的含义是：在最短路径中，到达顶点 $i$ 之前的那个点是 $k$。
- **推导方向**：**逆向推导**。从终点出发，找它的前驱，再找前驱的前驱，一直追溯到源点。
- **数据结构思想**：这种“逆向链表”的结构非常适合用栈（Stack）来存储，输出时再弹栈就能得到正向路径。
## 代码实现
- **数据结构准备**：
    - 图用 **邻接矩阵** `arcs[][]` 表示。
    - `dist[i]`：记录当前最短路径长度。
- **初始化**：
    - 集合 S 初始只包含源点 $v$ 。
    - `dist` 数组初始化为源点到各邻居的直接距离。
- **主循环 (Main Loop)**：
    - `for (i=0; i < n-1; i++)` 4：
        - 因为一共有 $n$ 个顶点，源点已在 S 中，所以只需要处理剩下的 $n-1$ 个顶点，循环 $n-1$ 次。
- **循环内部操作**：
    1. **选择 (Select)**：
        - 在 U 中选择一个顶点 u，满足 $dist[u]$  最短 。
        - **操作**：扫描一遍 U 列表，找到最小值。
    2. **加入集合 (Add)**
        - 将顶点 u 加入到集合 S 中。
    3. **松弛 (Relax - 核心)**：
        - 对于每个属于 U 的顶点 j，检查是否需要更新 。
        - **判断条件**：`if (dist[j] > dist[u] + arcs[u][j])` 。
        - **更新动作**：`dist[j] = dist[u] + arcs[u][j]`。
- **时间复杂度分析**：
    - 外层循环执行 $n-1$ 次。
    - 内层“找最小”需要扫描所有点（$O(n)$）。
    - 内层“松弛”需要扫描所有邻居（最坏 $O(n)$）。
    - 总复杂度：$(n-1) \times (n + n) \approx O(n^2)$ 。
## 思考
- **思考 1：单终点问题**
    - **问题**：如果我只想要从源点 $v$ 到某一个特定终点 $k$ 的最短路径，能用 Dijkstra 吗？
        - **能用**。只需要在代码中加一个判断：当“选择”步骤中选出的顶点 $u$ 恰好就是终点 $k$ 时，算法可以**提前终止**（Break）。
        - **复杂度**：虽然可以提前停，但在最坏情况下（比如 $k$ 是离源点最远的那个点），我们依然需要遍历所有节点。所以时间复杂度**依然是 $O(n^2)$**。
- **思考 2：负权边的死穴
    - **场景**：PPT 左图展示了一个三角形图：
        - $v_1 \rightarrow v_2$ 权值为 3。
        - $v_1 \rightarrow v_3$ 权值为 2。
        - $v_2 \rightarrow v_3$ 权值为 **-2** (负权边)。
    - **Dijkstra 的错误执行过程**：
        1. **第一步（初始化）**：$S=\{v_1\}$。$dist[v_2]=3$, $dist[v_3]=2$。
        2. **第二步（选择）**：在 $v_2$ (3) 和 $v_3$ (2) 中选最小。
            - 算法选择了 **$v_3$**，因为它距离 2 最小。
            - **关键错误发生点**：Dijkstra 算法一旦把顶点加入 S，就认为**它的最短路径已经确定了，永不回头修改**。所以算法判定 $v_1 \to v_3$ 的最短距离是 **2**。
        3. **真实情况**：
            - 如果我们走 $v_1 \rightarrow v_2 \rightarrow v_3$，总长度是 $3 + (-2) = \textbf{1}$。
            - 显然 $1 < 2$，真实的最短路径应该是经过 $v_2$ 的那条。
    - **结论**：因为 Dijkstra 贪心地选择了直接相连的 $v_3$，而忽略了可能存在一条“虽然先走得远一点（到 $v_2$ 是 3），但后面可以通过负权边把距离减回来”的路径。所以，**Dijkstra 无法正确求解带负权边的图**。
# 多源最短路径
## Floyd算法
处理小规模、稠密、可能带负权的图
### 基本定义
- **输入是什么？** 一个邻接矩阵（Adjacency Matrix），记录了顶点间直接相连的距离（或代价）。
- **目标是什么？** 一个最终的矩阵，其中 $D[i][j]$ 不再是直接距离，而是经过任意中转后的**最短**距离。
- **核心逻辑（重点）：** 这里的核心在于理解**中间顶点**的概念。算法不是一步到位的，而是分阶段进行的。
    - 第0阶段：只允许经过顶点 $v_0$ 中转。
    - 第1阶段：允许经过 $v_0, v_1$ 中转。
    - ...
    - 第 $k$ 阶段：允许经过序号 $\le k$ 的顶点中转。

- **存储结构**：使用二维数组 $D[i][j]$ 存储。
- **状态定义的演变**（这是理解 Floyd 的关键）：
    - 引入了一个上标的概念：$D^{(k)}[i][j]$ 。
    - **含义**：表示从顶点 $i$ 到顶点 $j$ 的最短路径长度，但这条路径上**所有中间顶点**的序号都必须 **不大于 $k$** 。
- **递推过程**：
    - 算法产生一个矩阵序列：$D^{(0)} \Rightarrow D^{(1)} \Rightarrow \dots \Rightarrow D^{(n-1)}$ 。
    - **$D^{(0)}$**：允许中间经过 $v_0$。
    - **$D^{(1)}$**：允许中间经过 $v_0, v_1$。
    - 以此类推，直到 **$D^{(n-1)}$**：允许经过所有顶点（$v_0$ 到 $v_{n-1}$），这时的距离就是最终的全局最短路径。
### 算法步骤

**第一步：初始矩阵 $D^{(-1)}$ **
- **含义**：这是图的原始快照。
- **观察**：
    - 矩阵中有不少 $\infty$（无穷大），表示两点之间没有直达路径。
    - 例如 $v_0$ 到 $v_4$ 是 $\infty$ 3。
    - 对角线全是 0。
**第二步：计算 $D^{(0)}$ (加入 $v_0$ 中转)**
- 操作逻辑：检查每一个格子 $D[i][j]$，看是否满足：$$D[i][0] + D[0][j] < D[i][j]$$即：“$i \to v_0 \to j$” 的距离是否比 “$i \to j$” 短？
- **关键点**：这一步主要会更新那些**与 $v_0$ 连通**的行和列。如果某行 $i$ 无法到达 $v_0$（$D[i][0]=\infty$），或者是 $v_0$ 无法到达某列 $j$（$D[0][j]=\infty$），则该数值不会变。
- **结果**：课件中展示了计算后的 $D^{(0)}$ 。你需要对比 $D^{(-1)}$ 和 $D^{(0)}$，观察哪些数字变小了。
**第三步：计算 $D^{(1)}$ (在 $D^{(0)}$ 基础上加入 $v_1$ 中转)**
- **重要提示**：**计算 $D^{(1)}$ 时，你的眼睛必须盯着 $D^{(0)}$ 看，而不是 $D^{(-1)}$** 这是初学者最容易犯的错误。
- 操作逻辑：检查是否满足：$$D^{(0)}[i][1] + D^{(0)}[1][j] < D^{(0)}[i][j]$$
- **案例分析**：
    - 在课件展示的 $D^{(1)}$ 中，你会发现矩阵数值进一步优化。
    - 例如，如果 $v_2 \to v_1$ 有路，且 $v_1 \to v_4$ 有路，那么 $v_2 \to v_4$ 的距离可能会被更新。
**第四步：计算 $D^{(2)}$** 
- **状态**：此时允许经过 $\{v_0, v_1, v_2\}$ 中转。
- **观察**：课件展示了 $D^{(2)}$ 的结果 6。
    - 矩阵变得越来越“稠密”（$\infty$ 越来越少），说明通过中转，原本不通的路现在通了。
**第五步：最终结果 $D^{(4)}$ (PPT Page 7)**
- **状态**：允许经过所有节点 $\{v_0, v_1, v_2, v_3, v_4\}$ 中转。
- **物理意义**：$D^{(4)}$ 给出了任意两点间不论几步到达的最短路长 。
- **结论**：此时矩阵中的每一个数字，就是该图中对应两点间的**全局最短路径**。
### 代码
```c
// 核心代码解析
void floyd(int arcs[][N], int n) // arcs是邻接矩阵，n是顶点数
{
    int i, j, k;

    // 1. 初始化
    // 注意：PPT这里为了简化省略了初始化的部分细节，实际写代码时
    // 你通常会把 arcs 复制给 D 数组，或者直接在 arcs 上修改（如果在位操作）
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            D[i][j] = arcs[i][j]; 

    // 2. 三重循环（算法核心）
    for (k = 0; k < n; k++)         // 第一层：k (中间节点) -> 最重要！
    {
        for (i = 0; i < n; i++)     // 第二层：i (起点)
        {
            for (j = 0; j < n; j++) // 第三层：j (终点)
            {
                // 状态转移方程的代码化
                if (D[i][k] + D[k][j] < D[i][j]) 
                {
                    D[i][j] = D[i][k] + D[k][j];
                }
            }
        }
    }
}
```
### 复杂度分析 
- **时间复杂度**：**$O(n^3)$** 
    - 非常直观：三层 `for` 循环，每层运行 $n$ 次。
    - 不管图是稀疏还是稠密，它都要跑满 $n^3$ 次。
- **空间复杂度**：**$O(n^2)$**
    - 需要一个二维数组来存储邻接矩阵。

### **思考 1：有负权边的图
- **场景**：图中存在权值为负数的边（如 $v_2 \to v_1$ 权值为 -2）。
- **问题**：Floyd 能否正确求得最短路径？
- **答案**：**能**。
- **解释**：Floyd 算法的逻辑是“只要经过中转点能让距离变短，就更新”。加法运算即使加上负数，$D[i][k] + D[k][j]$ 的逻辑依然成立。只要路径长度是有限的，它就能算出最小值。
### **思考 2：有负权回路的图
- **场景**：图中有一个环，环上的边权之和小于 0。
    - 例如：$A \to B$ 是 2， $B \to A$ 是 -5。走一圈 $A \to B \to A$ 长度是 -3。
- **问题**：能否求得最短路径？为什么？
- **答案**：**不能**。
- **解释**：
    1. **数学上无解**：如果存在负权回路，你可以在回路里无限转圈，每转一圈路径长度就减小一点，路径长度会趋向于 $-\infty$。此时“最短路径”这个概念本身就不存在了。
    2. **算法表现**：在 Floyd 算法运行结束后，如果你发现对角线上的元素 $D[i][i] < 0$，就说明图中存在负权回路（正常情况下 $D[i][i]$ 应该永远是 0）。

