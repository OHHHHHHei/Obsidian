# 图的连通性与最小生成树的定义与性质

**连通性与生成树**
- **遍历的本质**： 我们在之前的课程学过深度优先（DFS）和广度优先（BFS）。课件指出，对于**连通图**，只需要调用一次遍历过程，从任意顶点出发，就能访问所有顶点。这些访问路径上的边和顶点，就构成了这个图的一棵**生成树** 。
- **如果图是不连通的呢** 
- 那就需要多次调用遍历，形成的叫**生成森林** 。

## 最小生成树

**定义**： 在一个连通网（带权图）中，可能存在多棵不同的生成树，但在这些树中，**所有边的权值之和最小**的那棵树，被称为最小生成树 。
- 最小生成树的树形可能不唯一，但**最小的权值之和是唯一的**。
## MST性质

- **场景设定**：把整个图的所有顶点分成**两拨**。
    - **第一拨（集合 $U$）**：比如是我们已经修好路的城市（“已选阵营”）。
    - **第二拨（集合 $V-U$）**：是还没修好路的城市（“未选阵营”）。
- **关注对象**：连接这两拨城市之间的**路**（边）。
    - 可能有好几条路都能从“已选阵营”通向“未选阵营”。
- **核心规则**：
    - 在所有这些连接“两拨人”的路中，**权值最小（最便宜）的那条路**，一定属于最小生成树！
# Prim算法
- **逻辑梳理**：
    1. **初始化**：算法需要一个起点。就像传染病扩散一样，先选一个“零号病人”（起点 $0$）进入集合 $U$。
    2. **循环扩展**：每一轮都执行我们在上一模块讲过的那个**MST性质**——寻找连接“内部”($U$) 和“外部”($V-U$) 的所有边中，权值最小的那一条。
    3. **状态更新**：选中一条边和对应的点后，将该点拉入 $U$，并更新可能的边界。
    4. **终止**：直到所有顶点都被拉入 $U$ 为止（$n$ 个顶点的图，需要 $n-1$ 步）。
- **重点提炼**：
    - Prim 算法是一种**构造性算法**，一步步把树“长”出来 。
    - **关键动作**：始终盯着“边界”看，谁离我最近，我就抓谁。
## 具体实现

- **记忆辅助（核心思想）**：计算机看不见图的全貌，它只能记数据。我们需要两个“记事本”（数组）来记录当前的状态。
    - **`lowcost[]`**：记录从外部顶点到集合 $U$ 的**最短距离**（即“过桥费”）。
    - **`closest[]`**：记录这个最短距离是连接到集合 $U$ 中的**哪个顶点**（即“桥的另一头是谁”）。
- **算法三部曲**：
    - **第一步：初始化**。以起点 $v$ 为中心，先把它周围的边填入记事本。
    - **第二步：选最小**。遍历 `lowcost`，找出还没有加入 $U$ 且权值最小的那个点 $k$。
    - **第三步：更新（关键）**。既然 $k$ 加入了 $U$，那么 $k$ 可能离某些外部顶点更近。如果经过 $k$ 过去更便宜，就修改记事本上的数据。
**阶段 1：初始化
```c
// 假设从顶点 v 开始
for (i = 0; i < g.vexnum; i++) {
    lowcost[i] = g.adjMatrix[v][i]; // 将起点 v 到所有点的距离填入 lowcost
    closest[i] = v;                 // 此时所有点的“靠山”都是 v
}
lowcost[v] = 0; // 标记起点 v 已经加入集合 U
```
- **讲解**：刚开始，$U$ 里只有 $v$。所以外面所有点到 $U$ 的距离，其实就是到 $v$ 的距离。
阶段 2：循环找最小
我们需要找 $n-1$ 个点，所以循环 $n-1$ 次 6。
```c
min = INF; // 先设为一个无穷大
k = -1;
for (j = 0; j < g.vexnum; j++) {
    // 两个条件：1. j 还没加入 U (lowcost[j]!=0)
    //           2. j 的权值比当前找到的 min 还小
    if (lowcost[j] != 0 && lowcost[j] < min) { [cite: 243]
        min = lowcost[j];
        k = j; // 记下这个目前最近的点 k
    }
}
// 循环结束，k 就是我们要拉入伙的那个点
printf("边(%d,%d)权为:%d\n", closest[k], k, min); // 输出结果
lowcost[k] = 0; // 必须操作：标记 k 加入集合 U
```
阶段 3：更新周围
这是最容易晕的地方。为什么 $k$ 进来了，要更新 lowcost？
因为 $k$ 的加入，让集合 $U$ 的“领土”扩张了。以前某些点离 $U$ 很远（甚至不连通），但现在它们可能离新成员 $k$ 很近。
```c
for (j = 0; j < g.vexnum; j++) {
    // 检查条件：
    // 1. j 还在外面 (lowcost[j] != 0)
    // 2. 新点 k 到 j 的距离 (g.adjMatrix[k][j]) 比 j 原来记录的距离 (lowcost[j]) 更短
    if (lowcost[j] != 0 && g.adjMatrix[k][j] < lowcost[j]) {
        lowcost[j] = g.adjMatrix[k][j]; // 更新最短距离
        closest[j] = k;        // j 的新靠山变成了 k
    }
}
```

## 算法分析
- 代码结构是：外层循环 $n-1$ 次，内层有两个并列的循环（找最小值 + 更新数组），每次都是遍历所有顶点 $n$。
- 总耗时：$(n-1) \times (n + n) \approx 2n^2$。
- **复杂度结论**：**$O(n^2)$** 。
# Kruskal算法
- **核心思想**：既然我们要找权值最小的生成树，那为什么不直接**按权值从小到大**把边挑出来呢？
- **执行规则**：将图中所有的边按权值排序。从最小的边开始选，只要这条边**不构成回路**（环），就把它加入集合。
- **终止条件**：直到选够了 $n-1$ 条边为止（连通 $n$ 个顶点）。
## 算法步骤
1.  **初始化**：把图中的 $n$ 个顶点看作是 $n$ 个独立的孤岛（此时生成树边集 $TE$ 为空）。
2. **排序**：把所有的边，不管在哪里，统一按权值**从小到大**排队 。
3. **循环选边**：
	- 拿出当前权值最小的那条边。
	- **判断**：加上这条边会不会形成**回路**？
		- **不会**（两个端点目前在不同的连通分量里）：**收录**这条边。
		- **会**（两个端点其实已经连通了）：**丢弃**这条边，看下一条。
4. **结束**：当收录的边数达到 $n-1$ 条时，算法结束 。
## 算法分析
**Kruskal 的时间复杂度**：**$O(e \log e)$** 。
- 主要时间花在给边**排序**上（$e$ 是边数）。

# 分析
**什么时候用谁？**
- **Prim 算法**：适合**稠密图**（边很多）。因为边多不影响它的速度，只看点。
- **Kruskal 算法**：适合**稀疏图**（边很少）。因为边少，排序快，效率极高。


