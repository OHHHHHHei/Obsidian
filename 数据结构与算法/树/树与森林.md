# 树的存储结构

## 顺序表

### 双亲表示法

**核心思想**：每个结点只存储一个信息：**它的父结点（双亲）是谁**。
**存储结构**：通常使用一个**连续的数组**来存储所有结点。数组中的每个元素（结点）包含两部分：
`[data | parent_index]`

 `data`：结点的数据。
 
`parent_index`：一个整数，指向其父结点在数组中的索引。

**根结点**：根结点没有父结点，所以它的 `parent_index` 通常设为一个特殊值（如 `-1`）。

**优点**：
**查找父结点：极快 (O(1))**。

**查找祖先**：非常快，沿着 `parent_index` 一直往上找到根即可 (O(树的高度))。

**存储结构简单**：一个数组即可，非常紧凑。
 
  **缺点**：
   **查找子结点：极慢 (O(N))**。你必须遍历**整个数组**，找出所有 `parent_index` 指向你的结点。
   
   **查找兄弟结点**：很慢 (O(N))。你需要先找到爸爸 (O(1))，然后再遍历整个数组找出爸爸的所有孩子 (O(N))。
   
   **最适用场景**：
   **并查集 (Disjoint Set Union)**。并查集的核心操作就是不断地“找祖宗”，这完美契合了双亲表示法。
## 链式存储

###  孩子链 (List of Children)

- **核心思想**：每个结点存储一个列表，该列表包含了它**所有的直接子结点**。
    
- **存储结构**：这通常有两种实现方式：
    
    1. **数组 + 链表（最常见）**：用一个数组存放所有结点。每个结点 `[data | first_child_pointer]`。这个指针指向一个**单独的链表**，链表中的每个结点 
	 `[child_index | next_sibling_pointer]` 用来存放它所有孩子的**索引**。
        
    2. **动态指针列表**：如果用面向对象语言，每个 `Node` 对象可能包含一个 `List<Node*>` 类型的成员，动态存储所有子结点的指针。
        
- **优点**：
    
    - **查找子结点：快 (O(k))**，其中 k 是该结点的子结点个数。只需遍历该结点的孩子链表。
        
    - **查找兄弟结点**：快 (O(k))。
        
- **缺点**：
    
    - **查找父结点：极慢 (O(N))**。你不知道谁指向你，必须遍历所有结点的所有孩子链表，看谁的孩子列表里有你。
        
    - **结构不统一**：如果用“数组+链表”法，会存在两种不同结构的结点（父结点 和 孩子链结点），处理起来比较繁琐。
        
- **最适用场景**：
    
    - 图的**邻接表 (Adjacency List)** 存储。图的邻接表本质上就是一种“孩子链”思想的实现。

## 孩子兄弟链 (Left-Child, Right-Sibling)

- **核心思想**：这是最巧妙、最常用的一种方法。每个结点**只存储两个指针**：
    
    1. **`first_child` (第一个孩子)**：指向它的**第一个**子结点。
        
    2. **`next_sibling` (下一个兄弟)**：指向与它**同辈**的**下一个**兄弟结点。
        
- **存储结构**：
    
    - `[data | first_child | next_sibling]`
        
- **关键特性：转化为二叉树**
    
    - 这是一个**革命性**的转变：它将一棵**多叉树**用一种**二叉树**的结构存储了起来！
        
    - 结点的 first_child 指针
        
        $\iff$ 对应二叉树的 left (左孩子) 指针。
        
    - 结点的 next_sibling 指针
        
        $\iff$ 对应二叉树的 right (右孩子) 指针。
        
- **优点**：
    
    - **结构统一且优雅**：所有结点的结构都是一样的 `[data, left, right]`，和二叉树完全相同。
        
    - **所有二叉树算法通用**：你可以直接把这棵树当作二叉树，对其进行先序、中序、后序遍历（例如，我们之前谈到的“树的先序”等于“二叉树的先序”，“树的后序”等于“二叉树的中序”）。
        
    - **查找子结点：快 (O(k))**。顺着 `first_child` 找到老大，然后顺着 `next_sibling` 找到老二、老三...
        
- **缺点**：
    
    - **查找父结点：依然很慢 (O(N))**。（除非你额外再加一个 `parent` 指针）。
        
    - **直观性稍差**：`right` 指针存的不是孩子而是兄弟，初学者容易混淆。



# 多叉树转换为二叉树

## 左孩子-右兄弟转换法

核心思想是：用二叉树的**左指针**指向原多叉树中的**第一个孩子**，用二叉树的**右指针**指向原多叉树中的**下一个兄弟**。

对于多叉树中的任意一个节点 $P$：

1. **左孩子:** $P$ 在转换后二叉树中的**左孩子**，是它在原多叉树中的**第一个孩子**。
2. **右兄弟:** $P$ 在转换后二叉树中的**右孩子**，是它在原多叉树中的**下一个兄弟**（与 $P$ 拥有相同父节点的、紧邻 $P$ 右侧的节点）。

![[Pasted image 20251021202342.png]] 


# 森林转换成二叉树

核心思想是：**把森林中第二棵树的根，看作是第一棵树根的“兄弟”；第三棵树的根，看作是第二棵树根的“兄弟”，以此类推。**

![[Pasted image 20251021202546.png]]

![[Pasted image 20251021202644.png]] 

本质上就是把森林中不同的树的根节点当成同一级的兄弟

# 把二叉树还原

转换的规则是“**左孩子-右兄弟**”。 那么，还原的规则就是“**左连孩子-右连兄弟**”。

### 通用规则：将二叉树还原为森林

这个算法是关键。给定一个二叉树的根节点 `B_Root`：

1. **寻找森林的根：**
    - 二叉树的根节点 `B_Root`，就是森林中**第一棵树**的根 `T_1`。
    - `B_Root` 的**右孩子**（如果存在），就是森林中**第二棵树**的根 `T_2`。
    - `B_Root` 的右孩子的**右孩子**（如果存在），就是森林中**第三棵树**的根 `T_3`。
    - ...以此类推。==**沿着二叉树根节点的右指针链，可以找到森林中所有的树。**== 
2. **为每棵树寻找孩子：**
    - 对于上面找到的任何一棵树的根（比如 `T_1`，它对应二叉树节点 `B_Root`）：
    - `T_1` 在多叉树中的**第一个孩子**，是 `B_Root` 在二叉树中的**左孩子**。
    - `T_1` 的**第二个孩子**，是 `B_Root` 左孩子的**右孩子**。
    - `T_1` 的**第三个孩子**，是 `B_Root` 左孩子的右孩子的**右孩子**。
    - ...以此类推。==**沿着二叉树节点的左指针往下，然后沿着右指针链，可以找到该节点在多叉树中的所有孩子。**== 
3. **递归还原：** 对上面找到的每一个孩子/每一棵树的根，重复步骤 2。

![[Pasted image 20251021203341.png]]
如图是沿着二叉树的右子树找到的所有的树

![[Pasted image 20251021203417.png]]
将找到的所有树进行转换