# 树的带权路径长度

路径长度：从一个结点到另一个结点所经过的结点数量
结点的权：每个结点被赋予的权重

树的带权路径长度：WPL
$$WPL_{\text{Tree}} = \sum_{i=1}^{n} (W_i \times L_i)$$ **树中所有叶子结点的带权路径长度之和**。

# 最优二叉树

## Huffman树

由相同叶结点构成的所有二叉树中WPL最短的树。

核心思想是： **让权值大的叶子节点，尽量靠近根节点（路径长度 L 尽量小）。** **让权值小的叶子节点，可以离根节点远一些（路径长度 L 比较大）。**

## Huffman树的构造方法

核心算法：贪心算法

给定 $n$ 个带权的==叶子==节点 $\{W_1, W_2, \dots, W_n\}$。

**构造步骤：**
1. **初始化：** 将这 $n$ 个节点视为 $n$ 棵独立的树，每棵树只有一个根节点（就是它自己）。把它们放入一个集合（通常是一个**最小堆**或**优先队列**，以便快速找到最小值）。
2. **迭代合并：** 只要集合中的树多于一棵，就重复以下操作：
    - **a. 选择：** 从集合中选择**权值最小的两棵树**，假设它们的根节点权值分别是 $W_a$ 和 $W_b$。
    - **b. 合并：** 创建一个新的**父节点**（这是一个内部节点，非叶子节点）。
    - **c. 赋权：** 这个新父节点的权值设置为 $W_{parent} = W_a + W_b$。（注意：这个权值仅用于构造过程中的比较）。
    - **d. 连接：** 将被选中的两棵树（根为 $W_a$ 和 $W_b$）作为这个新父节点的左右孩子。（左右顺序不影响最终的WPL）。
    - **e. 放回：** 从集合中**移除**原来的两棵树（$W_a$ 和 $W_b$），并将这棵以 $W_{parent}$ 为根的**新树**放入集合中。
3. **完成：** 当集合中只剩下一棵树时，这棵树就是构造完成的哈夫曼树。

## Huffman树的存储结构

```cpp 
// 哈夫曼树节点结构

typedef struct HuffmanNode {

    int weight;             // 权重

    int parent;             // 父节点索引

    int lchild;             // 左孩子索引

    int rchild;             // 右孩子索引

} HuffmanNode;
```

$n$ 为叶子结点数

Huffman树的结点数 = $2 \times n - 1$ 
# Huffman编码

### 为什么需要哈夫曼编码？（可变长度）

我们常规的编码方式，比如 ASCII 码，是**固定长度编码**。例如，'A' 是 `01000001` (8位)，'B' 是 `01000010` (8位)。不管这个字符是常用还是罕用，都用8位来存储。

这样做的好处是简单、易于解码，但缺点是**浪费空间**。

哈夫曼编码的核心思想：

对于一篇文档，出现次数多（频率高）的字符，应该使用更短的编码；出现次数少（频率低）的字符，可以使用更长的编码。

这样，文档的**总编码长度**（$\sum$ 字符频率 $\times$ 编码长度）将会最小。这正好就是我们之前讨论的**WPL（带权路径长度** 最小化问题！

- **权值 (W)** $\rightarrow$ 字符的**频率 (Frequency)**
    
- **路径长度 (L)** $\rightarrow$ 字符的**编码长度 (Code Length)**
    
- **最小化 WPL** $\rightarrow$ **最小化总编码长度**

### 编码的生成（利用哈夫曼树）

1. **统计频率：** 统计需要编码的数据中，每个符号（例如字符）出现的频率（次数）。
    
2. **构建哈夫曼树：** 以这些频率作为权值，按照我们前一节讨论的方法，构造一棵哈夫曼树。
    
3. **分配编码：** 在构造好的哈夫曼树上，从根节点开始：
    
    - **约定：** 通常约定，通往**左孩子**的路径记为 **'0'**，通往**右孩子**的路径记为 **'1'** 
    
4. **生成编码表：** 从根节点出发，到**每一个叶子节点**（代表一个字符）所经过的路径，就是该字符的哈夫曼编码。


### 关键特性：前缀编码

哈夫曼编码有一个至关重要的特性，使其能够被正确解码：**它是一种前缀编码 (Prefix Code)**。

**前缀编码**的意思是：**集合中没有任何一个编码是另一个编码的前缀。**

- 看我们的编码表：{0, 10, 110, 111}
    
- `0` 不是 `10` 的前缀。
    
- `10` 不是 `110` 的前缀。
    
- ...（以此类推）
    

**为什么这个特性很重要？** 因为它保证了解码时的**唯一性**。当解码器读取 `0` 时，它知道这**一定是 A**，不可能是 B 或 C 或 D 的开头，所以它可以立刻输出 A 并回到根节点，而不需要往后“多看几位”来判断。

在哈夫曼树的结构中，所有字符都在**叶子节点**上，而编码是**从根到叶子的路径**。一个叶子节点的路径**永远不可能**成为另一个叶子节点路径的前缀（因为到了叶子节点，路径就停止了），这就**天然保证了**哈夫曼编码一定是前缀码。

### Huffman编码的解码

#### 解码的前提

要成功解码，你**必须**拥有两样东西：

1. **压缩后的二进制流 (Bitstream)：** 比如 `01001111100`。
    
2. **与编码时所用完全相同的哈夫曼树**：解码方和编码方必须“约定”好同一棵树。

### 解码（解压缩）算法

解码算法是一个简单的循环过程，它从树的**根节点**开始：

1. **从根节点开始：** 将你的“位置”指针指向哈夫曼树的**根 (Root)**。
    
2. **读取一个比特：** 从二进制流中读取**一位** (bit)。
    
3. **遍历树：**
    
    - 如果读到的是 **'0'**，就移动到当前节点的**左孩子**。
        
    - 如果读到的是 **'1'**，就移动到当前节点的**右孩子**。
        
4. **检查当前节点：**
    
    - **如果是内部节点（非叶子）**：说明一个字符的编码还没结束。**返回步骤 2**，继续读取下一位比特。
        
    - **如果是叶子节点**：恭喜，你找到了一个完整的编码！
        
        - **a. 输出：** 将这个叶子节点代表的字符（比如 'A'）输出或保存下来。
            
        - **b. 重置：** **将你的位置指针放回到树的根节点**，准备解码下一个字符。
            
5. **重复：** 只要二进制流中还有数据，就重复步骤 2-4。