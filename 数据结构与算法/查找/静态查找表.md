# 查找表

- **查找表 (Search Table)**：
    - 这就好比是一个数据库或数组，它是由**同一类型**的数据元素构成的集合。
- **主关键字 (Primary Key)**：
    - 这是数据记录中最重要的项，用来**唯一标识**一条记录。
    - **例子**：学生的学号是主关键字（每个人都不一样），但姓名不是（可能重名）。
- **查找操作的结果**：
    - **成功**：找到了关键字等于给定值 $k$ 的记录。此时通常返回该记录的信息或它在内存/数组中的位置（下标）。
    - **失败**：找遍了都没找到，返回失败提示（在C语言中常返回 -1 或 NULL）。
- **分类：静态 vs 动态**
    
    - **静态查找表 (Static Search Table)**：只做“查”的操作（查询、检索）。**不**在查找过程中插入或删除元素。这就像你查一本印好的字典。
    - **动态查找表 (Dynamic Search Table)**：在查找过程中，如果没找到，可能会把这个元素**插入**进去；或者如果找到了，可能会把它**删除**。这就像你在维护一个实时的用户登录缓存

# **平均查找长度 ASL**

这是本章的第一个数学难点，也是计算题的必考点。

- **为什么要引入 ASL？** 
    - 查找算法的时间主要耗费在**关键字的比较**上。
    - 我们不能只看最好情况（一次找到）或最坏情况（最后才找到），而要看**平均**情况下需要比较多少次。
- **ASL 定义公式详解**

$$ASL = \sum_{i=1}^{n} p_{i} c_{i}$$
- **$n$**：查找表中记录的总个数。
- **$i$**：表示第 $i$ 个记录。
- **$p_i$**：查找第 $i$ 个记录的**概率**。
	- 在绝大多数考试和工程假设中，我们认为查找每个记录的可能性是相等的。所以 $p_i = \frac{1}{n}$ 。
- **$c_i$**：找到第 $i$ 个记录时，实际已经进行过的**比较次数**。
- **推导理解**：这就是概率论中的**数学期望**。即：$$E[\text{比较次数}] = \sum (\text{概率} \times \text{该次比较次数})$$
- **ASL 的两种情况**
    1. **$ASL_{\text{成功}}$**：在表中**能找到**目标元素时的平均比较次数。
    2. **$ASL_{\text{不成功}}$**：在表中**找不到**目标元素时，确定“不存在”这一事实所需要的平均比较次数。
- **经典例题解析（PPT 第 4 页表格）**
![[Pasted image 20251202200619.png]]
    - **场景**：有一个包含 9 个元素的表。
    - **数据**：
        - 第 1 个位置比较 1 次找到。
        - 第 2 个位置比较 2 次找到。
        - ...
        - 第 9 个位置比较 9 次找到。
    - **计算 $ASL_{\text{成功}}$**：
        - 前提假设概率相等，即 $p_i = \frac{1}{9}$。
        - $c_1=1, c_2=2, ..., c_9=9$。
        - 代入公式：$$ASL_{\text{成功}} = \frac{1}{9} \times (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)$$$$ASL_{\text{成功}} = \frac{45}{9} = 5$$
    - **含义**：在这个表中，平均只要比较 5 次就能找到目标。

# 静态查找表

查找方法主要有：顺序查找，二分查找，分块查找
## 顺序查找

### **数据结构定义**
```c
#define MAXL <表中最多记录个数> // 定义最大长度，比如 100
typedef struct {
	KeyType key;   // 关键字：这是我们查找依据的核心，比如学号
	InfoType data; // 其他数据项：比如姓名、成绩等，查到了就顺便带出来
} RecType;         // RecType 代表 "Record Type"（记录类型）

RecType R[MAXL];   // 定义一个数组 R，这就是我们的“查找表”
```
-  **逻辑**：把“关键字”和“其他信息”打包成一个结构体 `RecType`，然后用一个数组 `R` 来存放这些结构体。
### **算法思路与实现**

- **直观图示（第 7 页）**：
    - 想象一个数组 `R[0]...R[n-1]`。
    - 给定义一个值 `k`。
    - 有一个箭头（索引 `i`）从 `R[0]` 开始，一步一步往右移。
    - 每移一步，就问一句：`R[i].key == k` 吗？
    - 如果相等 $\rightarrow$ **成功**
    - 如果走到了最后（`i=n`）还没找到 $\rightarrow$ **失败**。
- **代码实现详解**：
```C
int SeqSearch(RecType R[], int n, KeyType k)
{
	int i = 0;
	// 核心循环：两个条件缺一不可
	// 1. i < n: 还没找完整个表，防止越界
	// 2. R[i].key != k: 当前这个不是我们要找的
	while (i < n && R[i].key != k) {
		i++; // 继续找下一个
	}

	// 循环结束主要有两种情况：
	if (i >= n) // 越界了意味着找遍了都没找到
		return -1; // 返回失败标记
	else
		return i;  // 此时 R[i].key 一定等于 k，返回下标
}
    ```
- **注意**：这个算法非常直白，就是利用 `while` 循环进行遍历。

### **效率分析：ASL 推导**
这是本模块的**重中之重**，要把数学推导搞清楚。
- **场景 1：查找成功时的 ASL**
    - 假设：查找每个记录的概率相等，即 $p_i = \frac{1}{n}$。
    - **思考比较次数 $c_i$**：
        - 找第 1 个元素（`R[0]`）：比较 **1** 次。
        - 找第 2 个元素（`R[1]`）：比较 **2** 次。
        - ...
        - 找第 $i$ 个元素：比较 **$i$** 次。
        - 找第 $n$ 个元素：比较 **$n$** 次。
    - 代入公式计算：
$$ASL_{\text{成功}} = \sum_{i=1}^{n} p_i c_i = \frac{1}{n} \times (1 + 2 + \dots + n)$$
    - 利用等差数列求和公式 $(1+n) \times \frac{n}{2}$：$$ASL_{\text{成功}} = \frac{1}{n} \times \frac{n(n+1)}{2} = \frac{n+1}{2}$$
    - **结论**：如果表有 $n$ 个元素，平均要比较大概一半（$\frac{n}{2}$）的元素才能找到。
- **场景 2：查找不成功时的 ASL**
    - 如果你要把整个表翻个底朝天确认“东西不在”，你需要比较多少次？
    - 必须和 `R[0]` 到 `R[n-1]` 的每一个都比一遍，才能死心。
    - 所以，**$ASL_{\text{不成功}} = n$**。
- **时间复杂度**：
    - 无论是 $(n+1)/2$ 还是 $n$，在数量级上都是 $n$ 的一次方。
    - 所以时间复杂度为 **$O(n)$**

## 二分查找

**前提条件**：线性表中的记录必须按关键字值**有序**（递增或递减）排列 。如果乱序，必须先排序。

### **核心思想**：
- 取区间中间位置记录 $R[\text{mid}]$。
- 计算 `mid = (low+high)/2` 是向下取整的。比如 `(0+1)/2 = 0`。
- 将给定值 $k$ 与 $R[\text{mid}].\text{key}$ 比较：
	- 若 $k == R[\text{mid}].\text{key}$：**成功**。
	- 若 $k < R[\text{mid}].\text{key}$：说明目标在**左区间**，修改右边界。
	- 若 $k > R[\text{mid}].\text{key}$：说明目标在**右区间**，修改左边界。
- **演示案例**：
    ![[Pasted image 20251202202928.png]]
    - **数据**：`2, 3, 10, 15, 20, 25, 28, 29, 30, 35, 40`（共11个，有序）。
    - **目标**：查找 `15`。
    - **步骤**：
        1. 初始：`low=0`, `high=10`。`mid = (0+10)/2 = 5`。
            - $R[5]=25$。因为 $15 < 25$，找左边，`high = 5-1 = 4`。
        2. 区间变 `0~4`。`mid = (0+4)/2 = 2`。
            - $R[2]=10$。因为 $15 > 10$，找右边，`low = 2+1 = 3`。
        3. 区间变 `3~4`。`mid = (3+4)/2 = 3`。
            - $R[3]=15$。**相等，查找成功**。
    - **比较次数**：3次
### **代码实现**
```c
int BinSearch(RecType R[], int n, KeyType k)
{
    int low = 0, high = n - 1, mid;
    while (low <= high) // 重点：要有等号！当区间只剩1个元素时也要检查
    {
        mid = (low + high) / 2;     // 计算中间位置
        if (R[mid].key == k)
            return mid;             // 找到了
        if (k < R[mid].key)
            high = mid - 1;         // 往左边找，high 左移
        else
            low = mid + 1;          // 往右边找，low 右移
    }
    return -1; // 循环结束还没找到，说明失败
}
```
- **思考题**：可以设计成递归算法吗？
    - **答案**：**可以**。只需把 `low`和`high`作为参数传递给递归函数即可。
### **判定树与 ASL 分析**

为了算 ASL，我们把折半查找的过程画成一棵**二叉树**，这叫**判定树**
- **判定树的构造：
![[Pasted image 20251202203151.png]]
- **根节点**：第一次比较的中间元素（如 `R[5]` 即 25）。
- **左子树**：左边区间的元素。
- **右子树**：右边区间的元素。
- **圆形节点（内部结点）**：表中真实存在的记录，找到它们代表**查找成功**。
- **方形节点（外部结点）**：判定树叶子节点留下的空隙，代表**查找失败**的区间。
#### **ASL 计算 - 成功情况
- **规律**：查找某个元素的比较次数 = 该节点在树中的**层数**。
- **例题**：11个节点的判定树。
	- 第1层：1个节点（比较1次）
	- 第2层：2个节点（比较2次）
	- 第3层：4个节点（比较3次）
	- 第4层：4个节点（比较4次）
- 计算：$$ASL_{\text{成功}} = \frac{1\times1 + 2\times2 + 4\times3 + 4\times4}{11} = \frac{33}{11} = 3$$
#### **ASL 计算 - 不成功情况**
- **难点**：查找失败意味着走到了**外部节点**（方形节点）。
- **规律**：失败时的比较次数 = 父节点（最后一个内部结点）的层数 = **外部节点所在层数 - 1**（注：有些教材定义不同，按本课件理解为路径上**内部结点**的总数）。
- **例题**：
	- 我们可以看到有很多方形节点（查找失败区间）。
	- 统计这棵树，有 4 个外部节点对应的路径长度是 3（比较3次）。
	- 有 8 个外部节点对应的路径长度是 4（比较4次）。
	- 总共有 12 个失败区间（$n$个元素的表有 $n+1$ 个失败区间）。
- 计算：$$ASL_{\text{不成功}} = \frac{4\times3 + 8\times4}{12} = \frac{44}{12} \approx 3.67$$
### 时间复杂度
- 判定树的高度 $h \approx \log_2(n+1)$ 。
- 所以时间复杂度为 **$O(\log_2 n)$** 。
- 这是一个非常高效的对数级别算法。

## 分块查找
**前提条件**：分块查找要求数据 **“分块有序”**。这是核心概念：块与块之间是有序的，但块内部可以是无序的 。
### **分块有序**
- **定义**：后一块中所有记录的关键字值均**大于**前一块的最大关键字值。
    - **注意**：每一块**内部**的记录不一定非要有序，可以是乱的。
- **例子**：
    - 有一堆数：`22, 14, 8` (第一块) | `34, 40, 31` (第二块)。
    - 第一块最大的 22 小于第二块里任何一个数，这就叫分块有序。
- **参数设定**：
    - **$n$**：总记录数（例如 25）。
    - **$b$**：块数（Blocks，例如 5 块）。
    - **$s$**：每块包含的记录数（Size，例如 5 个）。
### **数据结构与查找过程**

- **建立索引表**：
    - 我们需要把每一块的**最大关键字**提出来，组成一个新的线性表，叫**索引表**。
    - 索引表包含两项：`key`（该块最大值）和 `link`（该块在主表中的起始下标）
    - **关键点**：因为块与块之间有序，所以**索引表一定是递增有序的**。
### 查找演示：
![[Pasted image 20251202204850.png]]
![[Pasted image 20251202204748.png]]
1. **第一步：查索引表**。
	- 索引表的 Keys 是 `[14, 34, 66, 100]`（假设）。
	- 我们要找 80。
	- 可以用**折半查找**或**顺序查找**在索引表中找第一个**大于等于** 80 的值。
	- 找到 `100`，对应的起始地址是 15（即第 4 块）。
	- _PPT 中假设对索引表折半查找，比较 2 次_。
2. **第二步：查数据块**。
	- 根据地址 15，跳到主数据表的第 4 块。
	- 在这一块内部进行**顺序查找**（因为块内是无序的，只能挨个找）。
	- _PPT 中假设在块中比较 4 次找到_。
- **总次数**：$2 + 4 = 6$ 次。
### 效率分析：ASL 推导
- 公式构成：
$$ASL = ASL_{\text{索引表}} + ASL_{\text{块内}}$$
- **具体计算**：
    - 假设总共有 $n$ 个记录，分成 $b$ 块，每块 $s$ 个记录（$b \approx n/s$）。
    - **索引表查找**：通常采用**折半查找**（因为索引表有序）。长度为 $b$ 的表，折半查找平均约 $\log_2(b+1)$ 次。
    - **块内查找**：只能**顺序查找**。长度为 $s$ 的块，平均 $s/2$ 次。
    - 总 ASL：
$$ASL \approx \log_2(\frac{n}{s} + 1) + \frac{s}{2}$$
- **结论**：它的效率介于折半查找和顺序查找之间。