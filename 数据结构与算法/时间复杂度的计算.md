
当你看到一段代码时，可以按照以下三个步骤来快速分析：

#### 第一步：找到基本操作和问题规模 $n$


- 分析代码，确定哪个是输入规模 $n$ （例如数组长度、循环次数等）。
    
- 找到那个**在循环或递归中执行次数最多**的语句，它就是“基本操作”。
    
#### 第二步：计算基本操作的执行次数 $T(n)$

- **$O(1)$：常数复杂度**
    
    - **特征**：代码的执行时间不随 $n$ 的变化而变化。
        
    - **例子**：没有循环、没有递归，只有顺序执行的语句。
```cpp
    int a = 1;
    int b = 2;
    int sum = a + b;
```

无论 $n$ 是多少，这段代码都只执行一次。

- **$O(n)$：线性复杂度**
    
    - **特征**：一层循环，循环次数与 $n$ 成正比。
        
    - **例子**：

    
```cpp
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += i; // 这是基本操作
    }
```
    
基本操作 `sum += i` 执行了 $n$ 次。 $T(n) = n$。

- **$O(\log n)$：对数复杂度**
    
    - **特征**：循环的步长（或范围）**成倍增加或减少**。
        
    - **例子**：二分查找（Binary Search）。
        
    
    C++
    
    ```
    int i = 1;
    while (i < n) {
        i = i * 2; // 基本操作
    }
    ```
    
    假设循环执行了 $x$ 次，则 $2^x = n$，解得 $x = \log_2 n$。所以 $T(n) = \log n$。
    
- **$O(n^2)$：平方复杂度**
    
    - **特征**：**两层嵌套循环**，每层循环都与 $n$ 相关。
        
    - **例子**：
    
```cpp
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 基本操作
        }
    }
```
    
基本操作执行了 $n \times n = n^2$ 次。 $T(n) = n^2$。
    
- **注意**：如果是 `for (int j = 0; j < i; j++)` 呢？它执行了 $1 + 2 + ... + (n-1) = \frac{n(n-1)}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$ 次。
        
- **$O(n \log n)$：线性对数复杂度**
    
    - **特征**：将一个 $O(\log n)$ 的操作执行了 $n$ 次（或者一层 $O(n)$ 的循环嵌套一个 $O(\log n)$ 的循环）。
        
    - **例子**：高效的排序算法，如归并排序、快速排序。
        
```cpp
    for (int i = 0; i < n; i++) {
        // 执行一次二分查找 (O(log n))
    }
```
总时间为 $T(n) = n \times \log n$。
#### 第三步：使用大O表示法进行简化

“快速精准”的关键在于“抓大放小”。

1. **只保留最高阶项**：如果 $T(n) = n^2 + n + 100$，那么最高阶是 $n^2$。当 $n$ 足够大时， $n$ 和 $100$ 相比 $n^2$ 可以忽略不计。
    
2. **去掉常数系数**：如果 $T(n) = 2n^2$ 或者 $T(n) = \frac{1}{2}n^2$，我们只关心它的趋势是 $n^2$ 级别的。
    

**应用举例：**

- $T(n) = 5n + 10 \implies O(n)$
    
- $T(n) = 3n^2 + 2n + 1 \implies O(n^2)$
    
- $T(n) = \frac{n(n-1)}{2} = \frac{1}{2}n^2 - \frac{1}{2}n \implies O(n^2)$
    
- $T(n) = 8\log n + n \implies O(n)$ (因为 $n$ 比 $\log n$ 增长得快)
